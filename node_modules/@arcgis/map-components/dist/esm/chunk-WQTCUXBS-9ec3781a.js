/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */
import { a as getAssetPath, f as forceUpdate } from './index-6e172aac.js';
import { l as importCoreAccessor, m as importCoreAccessorSupportDecorators, i as importCoreReactiveUtils } from './index-0bc55ca5.js';

// src/stencil.ts
function retrieveComponentMeta(component) {
  const constructor = component.constructor;
  const members = constructor.__registerControllers?.(component) ?? void 0;
  constructor.__registerControllers = void 0;
  if (typeof members !== "object")
    throw new Error(
      "Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config."
    );
  component.manager.internals.members = members;
}
function parsePropertyValue(value, type = 8 /* Any */) {
  const isComplex = value == null || typeof value === "object" || typeof value === "function";
  if (isComplex)
    return value;
  if ((type & 4 /* Boolean */) !== 0)
    return value === "false" ? false : value === "" || !!value;
  else if ((type & 2 /* Number */) !== 0)
    return Number.parseFloat(value.toString());
  else if ((type & 1 /* String */) !== 0)
    return String(value);
  else
    return value;
}
var makeMemberFilter = (filter) => (component) => {
  const members = component.manager.internals.members;
  return Object.entries(members ?? {}).filter(([_name, [propType]]) => (propType & filter) !== 0).map(([name]) => name);
};
var getPropLikeMembers = makeMemberFilter(63 /* PropLike */);
var getMemberType = (component, name) => component.manager.internals.members?.[name]?.[0];
function getPropType(component, name) {
  const type = getMemberType(component, name);
  if (type === void 0)
    return void 0;
  else if (type & 32 /* State */)
    return "state";
  else
    return "prop";
}

// ../components-utils/dist/index.js
var Deferred = class {
  /**
   * Creates a new deferred promise.
   */
  constructor() {
    this.resolve = () => void 0;
    this.reject = () => void 0;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
function inTargetElement(element, targetElement) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement === targetElement) {
      return true;
    }
    if (!currentElement.parentNode) {
      return false;
    }
    if (currentElement.parentNode instanceof ShadowRoot) {
      currentElement = currentElement.parentNode.host;
    } else {
      currentElement = currentElement.parentNode;
    }
  }
  return false;
}
function observeAncestorsMutation(element, attributeFilter, callback) {
  const { subscribe } = observe(attributeFilter);
  return subscribe((mutations) => {
    const matched = mutations.some((mutation) => inTargetElement(element, mutation.target));
    if (matched)
      callback();
  });
}
var observers = {};
function observe(attributeFilter) {
  const attributes = attributeFilter.join(",");
  const previousObserver = observers[attributes];
  if (previousObserver !== void 0)
    return previousObserver;
  const subscribers = /* @__PURE__ */ new Set();
  const mutationObserver = new MutationObserver((mutations) => subscribers.forEach((callback) => callback(mutations)));
  mutationObserver.observe(document.documentElement, {
    attributes: true,
    attributeFilter,
    subtree: true
  });
  const observer = {
    subscribe(callback) {
      subscribers.add(callback);
      return {
        remove: () => {
          subscribers.delete(callback);
          if (subscribers.size === 0) {
            mutationObserver.disconnect();
            observers[attributes] = void 0;
          }
        }
      };
    }
  };
  observers[attributes] = observer;
  return observer;
}
function closestElement(base, selector) {
  let currentElement = base;
  while (currentElement) {
    const element = currentElement.closest(selector);
    if (element) {
      return element;
    }
    const rootElement = currentElement.getRootNode();
    if (rootElement === document) {
      return null;
    }
    currentElement = rootElement.host;
  }
  return null;
}
function getElementAttribute(el, prop, fallbackValue) {
  const closest = closestElement(el, `[${prop}]`);
  return closest?.getAttribute(prop) ?? fallbackValue;
}
function safeCall(callback) {
  try {
    return callback?.();
  } catch (error) {
    console.error(error, callback);
  }
  return void 0;
}
async function safeAsyncCall(callback) {
  try {
    return await callback();
  } catch (error) {
    console.error(error, callback);
  }
  return void 0;
}
var capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
var camelToHuman = (value) => capitalize(value.replaceAll(/([a-z])([A-Z])/gu, "$1 $2"));
var supportedLocales = /* @__PURE__ */ new Set([
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "el",
  "en",
  "es",
  "et",
  "fi",
  "fr",
  "he",
  "hr",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "lt",
  "lv",
  "nl",
  "nb",
  "pl",
  "pt-BR",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
]);
var defaultLocale = "en";
async function fetchT9NStringsBundle(locale, assetsPath, prefix = "") {
  const path = `${assetsPath}/${prefix}`;
  const filePath = `${path}${locale}.json`;
  t9nStringsCache[filePath] ?? (t9nStringsCache[filePath] = fetchBundle(locale, path));
  return await t9nStringsCache[filePath];
}
var t9nStringsCache = {};
async function fetchBundle(locale, path) {
  const filePath = `${path}${locale}.json`;
  try {
    const response = await fetch(filePath);
    if (response.ok)
      return await response.json();
  } catch (error) {
    console.error(error);
    return fallbackBundle;
  }
  if (locale === defaultLocale)
    return fallbackBundle;
  return await fetchBundle(defaultLocale, path);
}
var fallbackBundle = new Proxy(
  {},
  {
    get: (_target, property) => camelToHuman(property.toString())
  }
);
function getElementLocales(element) {
  const lang = getElementAttribute(element, "lang", navigator.language || defaultLocale);
  if (supportedLocales.has(lang)) {
    return { lang, t9nLocale: lang };
  }
  const rootCode = lang.slice(0, 2);
  return { lang, t9nLocale: supportedLocales.has(rootCode) ? rootCode : defaultLocale };
}
function startLocaleObserver(element, assetsPath, onUpdated, assetName) {
  let result = void 0;
  const callback = () => void updateComponentLocateState(element, assetsPath, assetName).then((newResult) => {
    if (result?.lang !== newResult.lang || result.t9nLocale !== newResult.t9nLocale || result.t9nStrings !== newResult.t9nStrings)
      onUpdated(newResult);
    result = newResult;
  }).catch(console.error);
  callback();
  return observeAncestorsMutation(element, ["lang"], callback);
}
async function updateComponentLocateState(element, assetsPath, assetName = element.tagName.toLowerCase().replace("arcgis-", "")) {
  const { lang, t9nLocale } = getElementLocales(element);
  const t9nAssetsPath = `${assetsPath}/${assetName}/t9n`;
  const prefix = `${assetName}.t9n.`;
  const t9nStrings = await fetchT9NStringsBundle(t9nLocale, t9nAssetsPath, prefix);
  return { lang, t9nLocale, t9nStrings };
}

// src/types.ts
var controllerSymbol = Symbol("controller");

// src/utils.ts
function extendObject(base, extend) {
  Object.entries(extend).forEach(([key, value]) => {
    if (key in base)
      throw new Error(`Unable to extend object because property "${key}" is already defined`);
    const thisBase = base;
    thisBase[key] = value;
  });
  return base;
}
var isController = (value) => typeof value === "object" && value !== null && (controllerSymbol in value || "hostConnected" in value || "hostDisconnected" in value || "hostUpdate" in value || "hostUpdated" in value);

// src/ControllerInternals.ts
var ControllerInternals = class {
  constructor() {
    this._ambientControllers = [];
    /**
     * The type definition has to be duplicated due to the
     * "'use' is referenced directly or indirectly in its own type annotation."
     * error
     */
    this.use = async (value, watchExports) => {
      const controller = this._useRefSync(value);
      if (controller === void 0) {
        if (typeof watchExports === "function") {
          const error = new Error(
            `Unable to resolve a controller from the provided value, so can't watch it's exports. ${unresolvableExports}`
          );
          console.error(error);
        }
        return value;
      }
      await controller.ready;
      if (typeof watchExports === "function") {
        if (controller.watchExports === void 0)
          throw new Error(`The controller must implement watchExports method to support watching exports`);
        const unsubscribe = controller.watchExports(
          (exports) => watchExports(exports, unsubscribe)
        );
      }
      return controller.exports;
    };
    this.useRef = async (value) => {
      const controller = this._useRefSync(value);
      if (controller === void 0)
        throw new Error(`Unable to resolve a controller from the provided value. ${unresolvableExports}`);
      await controller.ready;
      return controller;
    };
    this.shouldBypassSetter = false;
    this.shouldBypassGetter = false;
    this.shouldBypassReadonly = false;
    /**
     * A map from component instance or component element to component instance.
     * To get from component instance or component element to component element,
     * you can just use the .el property
     */
    this.elementToInstance = /* @__PURE__ */ new WeakMap();
  }
  /*
   * Allow controllers to implicitly retrieve which component they are in, to
   * improve DX (avoids the need to pass "this" explicitly for each controller)
   */
  setAmbientComponent(component) {
    if (this._ambientComponent === component)
      return;
    this._ambientComponent = component;
    queueMicrotask(() => {
      if (this._ambientComponent === component)
        this._ambientComponent = void 0;
    });
  }
  retrieveComponent(name) {
    if (this._ambientComponent === void 0)
      throw new Error(
        [
          `Unable to find out which component ${name || "this"} controller `,
          "belongs to. This might happen if you tried to create a controller ",
          "outside the component. If so, please wrap your controller ",
          "definition in an arrow function, ",
          "`const myController = ()=>makeController(...);` and call that",
          "function inside the component `my = myController();`, or ",
          "define your controller using makeGenericController/GenericController ",
          "instead.\n",
          "If you wish to use a controller inside an async controller, ",
          "make sure you are using controller.use.\n",
          "You might also have multiple instances of Controllers loaded"
        ].join("\n")
      );
    return this._ambientComponent;
  }
  /*
   * Aids proxyExports() in knowing who is it's host
   */
  setParentController(controller) {
    if (controller === void 0) {
      this._ambientControllers = [];
      return;
    }
    const index = this._ambientControllers.indexOf(controller);
    this._ambientControllers = index === -1 ? [...this._ambientControllers, controller] : this._ambientControllers.slice(0, index + 1);
    queueMicrotask(() => {
      this._ambientControllers = [];
    });
  }
  retrieveParentControllers() {
    return this._ambientControllers;
  }
  /*
   * Aids controller.use in retrieving controller value when it receives
   * controller exports, rather than the controller itself
   */
  setAmbientChildController(controller) {
    if (this._ambientChildController === controller)
      return;
    this._ambientChildController = controller;
    queueMicrotask(() => {
      if (this._ambientChildController === controller)
        this._ambientChildController = void 0;
    });
  }
  retrieveAmbientChildController() {
    const controller = this._ambientChildController;
    this._ambientChildController = void 0;
    return controller;
  }
  /**
   * Try to resolve a controller, without awaiting it's load
   */
  _useRefSync(value) {
    const ambientChildController = this.retrieveAmbientChildController();
    if (ambientChildController !== void 0)
      return ambientChildController;
    const component = Controller.internals.retrieveComponent();
    const controller = component.manager.internals.resolveExports(value);
    if (controller !== void 0)
      return controller;
    if (isController(value))
      return value;
    return void 0;
  }
};
var unresolvableExports = [
  "The value you passed is not a controller and not a controller exports. If ",
  "your controller exports a literal value, try making your controller export ",
  "an object instead"
].join("");

// src/Controller.ts
var _a;
var _Controller = class _Controller {
  constructor(component) {
    this._ready = new Deferred();
    this._lifecycleDisconnected = [];
    this.connectedCalled = false;
    this.willLoadCalled = false;
    this.didLoadCalled = false;
    this[_a] = true;
    this.ready = this._ready.promise;
    /*
     * Setting default exports to "this" so that controllers that don't use
     * exports/proxyExports(), could still be used as if they did
     * (i.e with controller.use)
     */
    this._exports = makeProvisionalValue(this);
    this._exportWatchers = /* @__PURE__ */ new Set();
    const resolvedComponent = toControllerHost(
      component ?? _Controller.internals.retrieveComponent(new.target.name)
    );
    Object.defineProperty(this, "component", {
      writable: false,
      enumerable: false,
      configurable: true,
      value: resolvedComponent
    });
    this.component.addController(this);
    const manager = this.component.manager;
    this.connected = manager?.connected;
    this.internals = manager?.internals;
    _Controller.internals.setParentController(this);
    if ("hostDestroy" in this)
      this.component.manager.ensureHasDestroy();
    if (manager !== void 0)
      queueMicrotask(() => this.catchUpLifecycle());
    const controller = this;
    this._callbacks = {
      hostConnected: "hostConnected" in this ? [() => controller.hostConnected?.()] : [],
      hostDisconnected: "hostDisconnected" in this ? [() => controller.hostDisconnected?.()] : [],
      hostLoad: "hostLoad" in this ? [() => controller.hostLoad?.()] : [],
      hostLoaded: "hostLoaded" in this ? [() => controller.hostLoaded?.()] : [],
      hostRender: "hostRender" in this ? [() => controller.hostRender?.()] : [],
      hostRendered: "hostRendered" in this ? [() => controller.hostRendered?.()] : [],
      hostUpdate: "hostUpdate" in this ? [() => controller.hostUpdate?.()] : [],
      hostUpdated: "hostUpdated" in this ? [() => controller.hostUpdated?.()] : [],
      hostDestroy: "hostDestroy" in this ? [() => controller.hostDestroy?.()] : [],
      hostLifecycle: "hostLifecycle" in this ? [() => controller.hostLifecycle?.()] : []
    };
  }
  /**
   * If controller is being added dynamically, after the component
   * construction, then trigger connected and load right away
   */
  catchUpLifecycle() {
    if (this.connectedCalled)
      return;
    this.triggerConnected();
    const loadWillStillHappen = !this.component.manager.willLoadCalled;
    if (loadWillStillHappen)
      return;
    this.triggerLoad().then(() => {
      const loadedWillStillHappen = !this.component.manager.didLoadCalled;
      if (loadedWillStillHappen)
        return;
      this.triggerLoaded();
    }).catch(console.error);
  }
  get exports() {
    return this._exports;
  }
  /**
   * Set controller's exports property (for usage with proxyExports()) and mark
   * controller as ready (for usage in other controllers). Also, triggers
   * re-render of the component
   */
  set exports(exports) {
    if (this._exports !== exports) {
      this._exports = exports;
      if (this.connectedCalled)
        this.component.requestUpdate();
      this._exportWatchers.forEach((callback) => callback(exports));
    }
    this._ready.resolve(exports);
  }
  setProvisionalExports(exports) {
    this._exports = makeProvisionalValue(exports);
    this._exportWatchers.forEach((callback) => callback(this._exports));
  }
  watchExports(callback) {
    const safeCallback = (exports) => safeCall(() => callback(exports));
    this._exportWatchers.add(safeCallback);
    return () => void this._exportWatchers.delete(safeCallback);
  }
  /**
   * A flexible utility for making sure a controller is loaded before it's used,
   * regardless of how or where a controller was defined:
   *
   * @example
   * makeGenericController(async (component, controller) => {
   *   // Await some controller from the component:
   *   await controller.use(component.someController);
   *   // Initialize new controllers
   *   await controller.use(load(importCoreReactiveUtils));
   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
   *   await controller.use(someController(component));
   * });
   *
   * @remarks
   * If your controller is not async, and you are not creating it async, then
   * you are not required to use controller.use - you can use it directly.
   * Similarly, accessing controllers after componentWillLoad callback does not
   * require awaiting them as they are guaranteed to be loaded by then.
   */
  get use() {
    _Controller.internals.setAmbientComponent(this.component);
    return _Controller.internals.use;
  }
  /**
   * Just like controller.use, but returns the controller itself, rather than it's
   * exports
   *
   * Use cases:
   * - You have a controller and you want to make sure it's loaded before you
   *   try to use it
   * - Your controller is not using exports, so you wish to access some props on
   *   it directly
   * - You have a controller exports only, and you want to retrieve the
   *   controller itself. This is useful if you wish to call .watchExports() or
   *   some other method on the controller
   */
  get useRef() {
    _Controller.internals.setAmbientComponent(this.component);
    return _Controller.internals.useRef;
  }
  /**
   * If you need to set a prop/state without triggering the custom setter you
   * defined with getSet()/dynamicGetSet()/readonly(), set the value inside
   * of this function
   *
   * @example
   * @Prop() readOnly = this.manager.readOnly(true);
   *
   * someAction(): void {
   *   this.manager.bypassSetter(()=>{
   *     this.readOnly = false;
   *   });
   * }
   *
   */
  bypassSetter(callback) {
    _Controller.internals.shouldBypassSetter = true;
    try {
      return callback();
    } finally {
      _Controller.internals.shouldBypassSetter = false;
    }
  }
  /**
   * Like bypassSetter, but only bypasses this.manager.readonly(), rather that
   * all setters set using this.manager.getSet()
   */
  bypassReadonly(callback) {
    _Controller.internals.shouldBypassReadonly = true;
    try {
      return callback();
    } finally {
      _Controller.internals.shouldBypassReadonly = false;
    }
  }
  /**
   * Property reads inside of this function will bypass any custom getter you
   * may have, and read the value directly from what's stored in Stencil.
   *
   * This also bypasses reactiveUtils integration - reading a property inside of
   * bypassGetter won't make that property tracked.
   *
   * @example
   * reactiveUtils.watch(
   *   ()=>{
   *     this.manager.bypassGetter(()=>{
   *       console.log(this.someProp);
   *     });
   *     return this.prop;
   *   },
   *   console.log
   * )
   */
  bypassGetter(callback) {
    _Controller.internals.shouldBypassGetter = true;
    try {
      return callback();
    } finally {
      _Controller.internals.shouldBypassGetter = false;
    }
  }
  /**
   * Like this.manager.getSet(), but can be called on any component's
   * state/prop from anywhere, rather than just from the default value
   */
  dynamicGetSet(name, getSet) {
    this.genericGetSet(name, getSet);
  }
  /**
   * Like dynamicGetSet, but less type-safe. Useful in cases when trying to set
   * getters/setters in place where property names & types are not known
   * statically
   */
  genericGetSet(property, getSet) {
    var _a2, _b;
    const genericGetSet = getSet;
    if (genericGetSet.get !== void 0) {
      (_a2 = this.internals.getters)[property] ?? (_a2[property] = []);
      this.internals.getters[property].unshift(genericGetSet.get);
    }
    if (genericGetSet.set !== void 0) {
      (_b = this.internals.setters)[property] ?? (_b[property] = []);
      this.internals.setters[property].unshift(genericGetSet.set);
    }
  }
  // FEATURE: improve typings
  /**
   * Dynamically set a watcher for any \@Prop()/\@State() property
   */
  watch(property, callback) {
    var _a2;
    const type = getMemberType(this.component, property);
    if (type === void 0)
      throw new Error(
        `Trying to watch a non-@Prop, non-@State property "${property}". Either convert it into a @State() or use manager.getSet/dynamicGetSet`
      );
    (_a2 = this.internals.allWatchers)[property] ?? (_a2[property] = []);
    const watchers = this.internals.allWatchers[property];
    const genericCallback = callback;
    const safeCallback = (newValue, oldValue, propertyName) => safeCall(() => genericCallback(newValue, oldValue, propertyName));
    watchers.push(safeCallback);
    return () => {
      const index = watchers.indexOf(safeCallback);
      if (index !== -1)
        watchers.splice(index, 1);
    };
  }
  // Register a lifecycle callback
  onConnected(callback) {
    this._callbacks.hostConnected.push(callback);
  }
  onDisconnected(callback) {
    this._callbacks.hostDisconnected.push(callback);
  }
  onLoad(callback) {
    this._callbacks.hostLoad.push(callback);
  }
  onLoaded(callback) {
    this._callbacks.hostLoaded.push(callback);
  }
  onRender(callback) {
    this._callbacks.hostRender.push(callback);
  }
  onRendered(callback) {
    this._callbacks.hostRendered.push(callback);
  }
  onUpdate(callback) {
    this._callbacks.hostUpdate.push(callback);
  }
  onUpdated(callback) {
    this._callbacks.hostUpdated.push(callback);
  }
  onDestroy(callback) {
    this.component.manager.ensureHasDestroy();
    this._callbacks.hostDestroy.push(callback);
  }
  onLifecycle(callback) {
    this._callbacks.hostLifecycle.push(callback);
    if (this.connectedCalled && this.component.el.isConnected)
      this._callLifecycle(callback);
  }
  // Call each lifecycle hook
  triggerConnected() {
    this._callbacks.hostConnected.forEach(safeCall);
    this.triggerLifecycle();
    this.connectedCalled = true;
  }
  triggerDisconnected() {
    this._callbacks.hostDisconnected.forEach(safeCall);
    this._lifecycleDisconnected.forEach(safeCall);
    this._lifecycleDisconnected = [];
  }
  async triggerLoad() {
    if (this.willLoadCalled)
      return;
    this.willLoadCalled = true;
    if (this._callbacks.hostLoad.length > 0)
      await Promise.allSettled(this._callbacks.hostLoad.map(safeAsyncCall));
    this._ready.resolve(this._exports);
  }
  triggerLoaded() {
    if (this.didLoadCalled)
      return;
    this._callbacks.hostLoaded.forEach(safeCall);
    this.didLoadCalled = true;
  }
  async triggerRender() {
    if (this._callbacks.hostRender.length > 0)
      await Promise.allSettled(this._callbacks.hostRender.map(safeAsyncCall));
  }
  triggerRendered() {
    this._callbacks.hostRendered.forEach(safeCall);
  }
  async triggerUpdate() {
    if (this._callbacks.hostUpdate.length > 0)
      await Promise.allSettled(this._callbacks.hostUpdate.map(safeAsyncCall));
  }
  triggerUpdated() {
    this._callbacks.hostUpdated.forEach(safeCall);
  }
  triggerDestroy() {
    this._callbacks.hostDestroy.forEach(safeCall);
  }
  triggerLifecycle() {
    this._callbacks.hostLifecycle.forEach((callback) => this._callLifecycle(callback));
  }
  _callLifecycle(callback) {
    const cleanupRaw = safeCall(callback);
    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];
    cleanup.forEach((cleanup2) => {
      if (typeof cleanup2 === "function")
        this._lifecycleDisconnected.push(cleanup2);
      else if (typeof cleanup2 === "object" && typeof cleanup2.remove === "function")
        this._lifecycleDisconnected.push(cleanup2.remove);
    });
  }
};
_a = controllerSymbol;
_Controller.internals = new ControllerInternals();
var Controller = _Controller;
var GenericController = class extends Controller {
  // Redundant constructor needed to improve typing
  constructor(component) {
    super(component);
  }
  // Overriding super's watch only to improve typing
  watch(property, callback) {
    return super.watch(
      property,
      callback
    );
  }
  /**
   * Silence "Property 'dynamicGetSet' in type
   * 'GenericController<Exports, Requires>' is not assignable to the same
   * property in base type 'Controller<Exports>'", as TypeScript is being overly
   * conservative here with what it allows
   */
  dynamicGetSet(property, getSet) {
    super.genericGetSet(property, getSet);
  }
};
function makeProvisionalValue(base) {
  if (typeof base !== "object" && typeof base !== "function" || base === null)
    return base;
  const proxy3 = new Proxy(base, {
    get(target, prop, receiver) {
      if (cyclical.has(prop) && prop in target && target[prop] === proxy3)
        return void 0;
      if (prop in target || prop in Promise.prototype || typeof prop === "symbol")
        return typeof target === "function" ? target[prop] : Reflect.get(target, prop, receiver);
      console.error(`Trying to access "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      return void 0;
    },
    set(target, prop, newValue, receiver) {
      console.error(`Trying to set "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      return Reflect.set(target, prop, newValue, receiver);
    }
  });
  return proxy3;
}
var cyclical = /* @__PURE__ */ new Set(["exports", "_exports"]);
var accessBeforeLoad = [
  "This might be the case if you are trying to access an async controller in ",
  "connectedCallback(). Or, if you are using it inside of ",
  "componentWillLoad()/another controller without controller.use. Example correct ",
  "usage:\n",
  "makeController(async (component, controller)=>{ await controller.use(someOtherController); });"
].join("");
function toControllerHost(component) {
  if ("addController" in component)
    return component;
  else
    throw new Error(
      "Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line"
    );
}

// src/trackPropertyKey.ts
function trackPropertyKey(object, onResolved, defaultValue) {
  const keys = Object.keys(object);
  const keyCount = keys.length;
  if (keyTrackMap === void 0)
    queueMicrotask(keyTrackResolve);
  keyTrackMap ?? (keyTrackMap = /* @__PURE__ */ new Map());
  let pendingTrackers = keyTrackMap.get(object);
  if (pendingTrackers === void 0) {
    pendingTrackers = { callbacks: [], keyCount };
    keyTrackMap.set(object, pendingTrackers);
  }
  if (pendingTrackers.keyCount !== keyCount) {
    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));
    pendingTrackers.callbacks = [];
    pendingTrackers.keyCount = keyCount;
  }
  pendingTrackers.callbacks.push((keys2) => {
    const callback = (key2) => safeCall(() => onResolved(key2));
    const key = keys2[keyCount];
    if (key === void 0)
      callback(void 0);
    else if (object[key] === defaultValue)
      callback(key);
    else
      callback(void 0);
  });
  return defaultValue;
}
var keyTrackMap = void 0;
function keyTrackResolve() {
  Array.from(keyTrackMap?.entries() ?? []).forEach(([object, { callbacks }]) => {
    const keys = Object.keys(object);
    callbacks.forEach((commit) => commit(keys));
  });
  keyTrackMap = void 0;
}

// src/ComponentInternals.ts
var ComponentInternals = class {
  constructor(component) {
    /**
     * When watchers are set, set then into `allWatchers`. When watchers are read
     * in the setter, read from `enabledWatchers`.
     * On connectedCallback(), controller manager does `enabledWatchers=allWatchers`.
     * Reasoning:
     * - This disables watchers until connected callback (matches behavior of
     *   Stencil's watchers)
     * - This removes in the setter to check if watchers were enabled already or
     *   not (as getters/setters are hot path, and should be streamlined)
     */
    this.enabledWatchers = {};
    this.allWatchers = {};
    this.trackKey = (hostsCandidates, onResolved, defaultValue) => {
      const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];
      let leftToResolve = candidateHosts.length + 1;
      const resolved = (resolution) => {
        leftToResolve -= 1;
        if (resolution !== void 0)
          leftToResolve = 0;
        if (leftToResolve === 0)
          onResolved(resolution);
      };
      candidateHosts.forEach(
        (host) => this.component.manager.trackPropertyKey(
          host,
          (key) => resolved(
            key === void 0 ? void 0 : {
              key,
              host,
              type: "property",
              domValue: void 0
            }
          ),
          defaultValue
        )
      );
      this.component.manager.trackPropKey((key, domValue) => {
        const propType = key === void 0 ? void 0 : getPropType(this.component, key);
        resolved(
          key === void 0 ? void 0 : {
            key,
            host: this.component,
            type: propType ?? "prop",
            domValue: propType === "prop" ? domValue : void 0
          }
        );
      }, defaultValue);
      return defaultValue;
    };
    this.trackPropKey = (onResolved, defaultValue, ignoreDefaultValueMismatch = false) => {
      if (this._trackedValue !== nothing && this._trackedValue !== defaultValue)
        this._firePropertyTrackers(void 0, void 0, void 0);
      if (this._keyTrackers.length === 0)
        queueMicrotask(() => this._firePropertyTrackers(void 0, void 0, void 0));
      this._trackedValue = defaultValue;
      this._keyTrackers.push(
        (key, value, previousValue) => safeCall(
          () => onResolved(defaultValue === value || ignoreDefaultValueMismatch ? key : void 0, previousValue)
        )
      );
      return defaultValue;
    };
    this._trackedValue = nothing;
    this._keyTrackers = [];
    this.getters = {};
    this.setters = {};
    this.accessorGetter = {};
    this.accessorSetter = {};
    this._exports = /* @__PURE__ */ new WeakMap();
    Object.defineProperty(this, "component", {
      writable: false,
      enumerable: false,
      configurable: true,
      value: component
    });
  }
  _firePropertyTrackers(key, value, oldValue) {
    const trackers = this._keyTrackers;
    this._trackedValue = nothing;
    this._keyTrackers = [];
    trackers.forEach((tracker) => tracker(key, value, oldValue));
  }
  /**
   * Configure a getter or setter for a given \@Prop/\@State
   *
   * Note, since props are defined on the prototype, they are shared between all
   * instances of a component. Thus, instead of passing a reference to the
   * getter/setter function, you should update the
   * ComponentInternals.getters/setters properties, and then call getSetProxy
   * to apply the changes to the prototype
   */
  getSetProxy(property, hasGetter, hasSetter) {
    const classPrototype = Object.getPrototypeOf(this.component);
    this._getSetProxy(classPrototype, property, hasGetter, hasSetter, "class");
    const htmlPrototype = Object.getPrototypeOf(this.component.el);
    if (classPrototype !== htmlPrototype)
      this._getSetProxy(htmlPrototype, property, hasGetter, hasSetter, "html");
  }
  _getSetProxy(prototype, name, hasGetter, hasSetter, type) {
    const component = this.component;
    const propType = getMemberType(component, name);
    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);
    const tolerateNotFound = type === "html";
    if (descriptor?.set === void 0 || descriptor.get === void 0)
      if (descriptor !== void 0 && "value" in descriptor)
        throw new Error(
          `getSet() should only be used on Stencil's @Prop and @State properties. For internal component properties, use regular get/set syntax. Tried to use it on "${name}" in ${component.el.tagName}`
        );
      else if (tolerateNotFound)
        return;
      else
        throw new Error(`Unable to find "${name}" property on the ${component.el.tagName} component`);
    const { get: originalGet, set: originalSet } = descriptor;
    const isGetterAlreadyOverwritten = customAccessor in originalGet;
    const isSetterAlreadyOverwritten = customAccessor in originalSet;
    const shouldOverwriteGet = !isGetterAlreadyOverwritten && hasGetter;
    const shouldOverwriteSet = !isSetterAlreadyOverwritten && hasSetter;
    if (!shouldOverwriteGet && !shouldOverwriteSet)
      return;
    const finalGetter = shouldOverwriteGet ? function getter() {
      let value = originalGet.call(this);
      const component2 = Controller.internals.elementToInstance.get(this);
      if (Controller.internals.shouldBypassGetter || component2 === void 0)
        return value;
      const internals = component2.manager.internals;
      value = internals.accessorGetter[name](value, name);
      const getters = internals.getters[name] ?? emptyArray;
      for (let i = 0; i < getters.length; i++)
        value = getters[i](value, name);
      return value;
    } : originalGet;
    const finalSetter = shouldOverwriteSet ? function setter(rawNewValue) {
      const oldValue = originalGet.call(this);
      let newValue = parsePropertyValue(rawNewValue, propType);
      const component2 = Controller.internals.elementToInstance.get(this);
      if (component2 === void 0) {
        originalSet.call(this, rawNewValue);
        return;
      }
      const internals = component2.manager.internals;
      if (newValue === oldValue)
        originalSet.call(this, rawNewValue);
      else {
        const setters = Controller.internals.shouldBypassSetter ? emptyArray : internals.setters[name] ?? emptyArray;
        for (let i = 0; i < setters.length; i++)
          newValue = setters[i](newValue, oldValue, name);
        newValue = internals.accessorSetter[name](newValue, oldValue, name);
        originalSet.call(this, newValue);
        if (newValue !== oldValue)
          internals.enabledWatchers[name]?.forEach((watcher) => watcher(newValue, oldValue, name));
      }
      if (internals._keyTrackers.length > 0)
        internals?._firePropertyTrackers(name, rawNewValue, oldValue);
    } : originalSet;
    if (shouldOverwriteGet)
      Object.defineProperty(finalGetter, customAccessor, { value: true });
    if (shouldOverwriteSet)
      Object.defineProperty(finalSetter, customAccessor, { value: true });
    Object.defineProperty(prototype, name, {
      ...descriptor,
      get: finalGetter,
      set: finalSetter
    });
  }
  /**
   * Associate an exports object with a controller for reverse lookup in
   * controller.use
   */
  markExports(controller, exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function")
      this._exports.set(exports, controller);
  }
  resolveExports(exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function")
      return this._exports.get(exports);
    else
      return void 0;
  }
};
var emptyArray = [];
var customAccessor = Symbol("controllersCustomAccessor");
var nothing = Symbol("nothing");
var accessorPromise = Promise.all([importCoreAccessor(), importCoreAccessorSupportDecorators()]);
function reactiveUtilsIntegration(component) {
  const members = getPropLikeMembers(component);
  const internals = component.manager.internals;
  members.forEach((name) => {
    internals.accessorGetter[name] = defaultGetterSetter;
    internals.accessorSetter[name] = defaultGetterSetter;
    internals.getSetProxy(name, true, true);
  });
  return async (enabledMembers = members) => {
    const [Accessor, { subclass, property }] = await accessorPromise;
    class AccessorSubclass extends Accessor {
    }
    const getter = (_value, propertyName) => accessor[propertyName];
    function setter(newValue, _oldValue, propertyName) {
      if (accessor !== void 0)
        accessor[propertyName] = newValue;
      return newValue;
    }
    component.manager.bypassGetter(
      () => enabledMembers.forEach((name) => {
        internals.accessorGetter[name] = getter;
        internals.accessorSetter[name] = setter;
        property({
          value: component[name]
        })(AccessorSubclass.prototype, name);
      })
    );
    const Subclass = subclass(component.el.tagName)(AccessorSubclass);
    const accessor = new Subclass();
  };
}
var defaultGetterSetter = (value) => value;

// src/ControllerManager.ts
var useControllerManager = (component) => new ControllerManager(component);
var ControllerManager = class extends GenericController {
  constructor(component) {
    const controllers = /* @__PURE__ */ new Set();
    const controllerHost = {
      addController: (controller) => {
        controllers.add(controller);
      },
      removeController: (controller) => {
        controllers.delete(controller);
      },
      requestUpdate: () => forceUpdate(component)
    };
    extendObject(component, controllerHost);
    super(component);
    this._connected = new Deferred();
    this.internals = new ComponentInternals(this.component);
    this.connected = this._connected.promise;
    this.hasDestroy = false;
    this.destroyed = false;
    this._updatePromise = new Deferred();
    this._originalLifecycles = {};
    /**
     * A magical solution to finding out what property name a given controller
     * on a given object was assigned to. Note, this does not work for properties
     * that have \@Prop() or \@State() decorator - for those, use
     * manager.trackPropKey() instead.
     *
     * @example
     * function trackMe<T>(defaultValue:T, component:BaseComponent):T {
     *   component.manager.trackPropertyKey(component, (key)=>console.log(key), defaultValue);
     *   return defaultValue;
     * }
     *
     * class MyComponent extends BaseComponent {
     *   // Will console log "myProp"
     *   myProp = trackMe('a', this);
     * }
     *
     */
    this.trackPropertyKey = trackPropertyKey;
    /**
     * Like manager.trackPropertyKey(), but for props that have \@State() or \@Prop()
     * decorator
     *
     * @example
     * function trackMe(component:BaseComponent) {
     *   component.manager.trackPropKey((key)=>console.log(key));
     * }
     *
     * class MyComponent extends BaseComponent {
     *   // Will console log "myProp"
     *   @Prop() myProp = trackMe(this);
     *
     *   // Will console log "myState"
     *   @State() myState = trackMe(this);
     * }
     */
    this.trackPropKey = this.internals.trackPropKey;
    /**
     * A combination of trackPropertyKey() and trackPropKey(). For usage when
     * you want to track a property, but don't know if it will be defined with the
     * \@Prop() decorator or not
     */
    this.trackKey = this.internals.trackKey;
    this._readonlySetter = (newValue, _oldValue, property) => {
      if (Controller.internals.shouldBypassReadonly)
        return newValue;
      const isProp = getPropType(this.component, property) === "prop";
      if (isProp)
        forceUpdate(this.component);
      throw new Error(
        `Cannot assign to read-only property "${property}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(
          newValue
        )}"`
      );
    };
    /**
     * In development, on hot module reload, controller would be re-initialized
     * with all Props and State values persistent, but properties lost. This unsafe
     * development-only API lets you set or get data for a controller that would
     * persist across hot reloads.
     */
    this.devOnlySetPersistentControllerData = void 0 ;
    this.devOnlyGetPersistentControllerData = void 0 ;
    this.component.manager = this;
    retrieveComponentMeta(component);
    this._controllers = controllers;
    this.exports = void 0;
    this.hasDestroy = "preserveOnDisconnect" in this.component && typeof this.component.destroy === "function";
    if (this.hasDestroy)
      this.watch("preserveOnDisconnect", () => this._preserveOnDisconnectWatcher());
    this._bindLifecycleMethods();
    Object.defineProperty(component, "updateComplete", {
      get: async () => await this._updatePromise.promise
    });
    this.internals.reactiveUtilsIntegration = reactiveUtilsIntegration(this.component);
    Controller.internals.setParentController(void 0);
    Controller.internals.setAmbientComponent(component);
    Controller.internals.elementToInstance.set(component.el, component);
    Controller.internals.elementToInstance.set(component, component);
  }
  _bindLifecycleMethods() {
    const component = this.component;
    this._originalLifecycles = {
      connectedCallback: component.connectedCallback,
      disconnectedCallback: component.disconnectedCallback,
      componentWillLoad: component.componentWillLoad,
      componentDidLoad: component.componentDidLoad,
      componentWillRender: component.componentWillRender,
      componentDidRender: component.componentDidRender,
      componentWillUpdate: component.componentWillUpdate,
      componentDidUpdate: component.componentDidUpdate,
      destroy: component.destroy
    };
    component.connectedCallback = this._connectedCallback.bind(this);
    component.disconnectedCallback = this._disconnectedCallback.bind(this);
    component.componentWillLoad = this._componentWillLoad.bind(this);
    component.componentDidLoad = this._componentDidLoad.bind(this);
    component.componentWillRender = this._componentWillRender.bind(this);
    component.componentDidRender = this._componentDidRender.bind(this);
    component.componentWillUpdate = this._componentWillUpdate.bind(this);
    component.componentDidUpdate = this._componentDidUpdate.bind(this);
    if (this.hasDestroy)
      component.destroy = this.destroy.bind(this);
  }
  /**
   * Throws an error if component does not implement destroy() lifecycle, but
   * tries to use it.
   */
  ensureHasDestroy() {
    if (!this.hasDestroy)
      throw new Error(destroyErrorMessage);
  }
  /**
   * Private because this is not supposed to be called by Component directly.
   * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk
   * calling lifecycle methods twice.
   */
  _connectedCallback() {
    if (this.destroyed) {
      const tagName = this.component.el.tagName.toLowerCase();
      this.component.el.remove();
      throw new Error(
        `The ${tagName} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the preserveOnDisconnect prop.`
      );
    }
    this.internals.enabledWatchers = this.internals.allWatchers;
    keyTrackResolve();
    this._connected.resolve();
    this._controllers.forEach(
      (controller) => "triggerConnected" in controller ? controller.triggerConnected() : safeCall(() => controller.hostConnected?.())
    );
    this._originalLifecycles.connectedCallback?.call(this.component);
  }
  _disconnectedCallback() {
    if (this.destroyed)
      return;
    this._controllers.forEach(
      (controller) => "triggerDisconnected" in controller ? controller.triggerDisconnected() : safeCall(() => controller.hostDisconnected?.())
    );
    this._originalLifecycles.disconnectedCallback?.call(this.component);
    if (this.hasDestroy)
      this._preserveOnDisconnectWatcher();
  }
  async _componentWillLoad() {
    await this.internals.reactiveUtilsIntegration();
    await Promise.allSettled(
      Array.from(
        this._controllers,
        async (controller) => "triggerLoad" in controller ? await controller.triggerLoad() : await safeAsyncCall(async () => await controller.hostLoad?.())
      )
    );
    await this._originalLifecycles.componentWillLoad?.call(this.component);
  }
  _componentDidLoad() {
    this._controllers.forEach(
      (controller) => "triggerLoaded" in controller ? controller.triggerLoaded() : safeCall(() => controller.hostLoaded?.())
    );
    this._originalLifecycles.componentDidLoad?.call(this.component);
  }
  async _componentWillRender() {
    await Promise.allSettled(
      Array.from(
        this._controllers,
        async (controller) => "triggerRender" in controller ? await controller.triggerRender() : await safeAsyncCall(async () => await controller.hostRender?.())
      )
    );
    await this._originalLifecycles.componentWillRender?.call(this.component);
  }
  _componentDidRender() {
    this._controllers.forEach(
      (controller) => "triggerRendered" in controller ? controller.triggerRendered() : safeCall(() => controller.hostRendered?.())
    );
    this._originalLifecycles.componentDidRender?.call(this.component);
  }
  async _componentWillUpdate() {
    await Promise.allSettled(
      Array.from(
        this._controllers,
        async (controller) => "triggerUpdate" in controller ? await controller.triggerUpdate() : await safeAsyncCall(async () => await controller.hostUpdate?.())
      )
    );
    await this._originalLifecycles.componentWillUpdate?.call(this.component);
  }
  _componentDidUpdate() {
    this._controllers.forEach(
      (controller) => "triggerUpdated" in controller ? controller.triggerUpdated() : safeCall(() => controller.hostUpdated?.())
    );
    this._originalLifecycles.componentDidUpdate?.call(this.component);
    const updatePromise = this._updatePromise;
    this._updatePromise = new Deferred();
    updatePromise.resolve(true);
  }
  async destroy() {
    this.ensureHasDestroy();
    if (this.destroyed)
      return;
    if (this.component.el.isConnected) {
      this.hasDestroy = false;
      this.component.el.remove();
      this.hasDestroy = true;
    }
    this.destroyed = true;
    this._controllers.forEach(
      (controller) => "triggerDestroy" in controller ? controller.triggerDestroy() : safeCall(() => controller.hostDestroy?.())
    );
    await this._originalLifecycles.destroy?.call(this.component);
  }
  _preserveOnDisconnectWatcher() {
    if (!this.component.el.isConnected && !this.component.preserveOnDisconnect)
      void this.destroy().catch(console.error);
  }
  /**
   * Make a @Prop() or @State() readonly (prevent overwriting default value).
   *
   * For internal properties, prefer TypeScript's "readonly" modifier instead.
   *
   * @example
   * // Defining readonly prop
   * @Prop({ reflect: true }) prop = this.manager.readonly('a');
   *
   * @example
   * // Overwriting readonly prop internally
   * this.manager.bypassReadonly(()=>{
   *   this.prop = 'b';
   * });
   *
   */
  readonly(value) {
    return this.getSet(value, { set: this._readonlySetter });
  }
  /**
   * Listen for any component's @State()/@Prop() change, and mutate it's
   * value before it is set.
   * This is necessary because Stencil's Compiler does not support get/set for
   * @State()/@Prop().
   * For private component properties, you should use regular get/set syntax.
   *
   * @example
   * @Prop() exampleProp = this.manager.getSet(defaultValue,{get,set})
   * @Prop() someProp = this.manager.getSet(
   *   undefined as string | undefined,
   *   {
   *     get: (value)=>value.trim(),
   *     set: (newValue,oldValue) => newValue.trim() ?? oldValue
   *   }
   * )
   *
   * @remarks
   * Unlike a native get/set, the get function receives the current attribute
   * value, and can modify it before returning it (or can disregard the current
   * value and get it from elsewhere instead).
   * Similarly, setter is called with the new and old value, and is expected to
   * return the final new value (or return the old value to undo the change)
   */
  getSet(defaultValue, getSet) {
    return this.component.manager.trackPropKey((name) => {
      var _a2;
      if (name === void 0)
        throw new Error(
          "Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})"
        );
      if (getSet.set === this._readonlySetter) {
        (_a2 = this.internals).readonlyProps ?? (_a2.readonlyProps = /* @__PURE__ */ new Set());
        this.internals.readonlyProps.add(name);
      }
      const genericComponent = this.component;
      const value = genericComponent[name];
      if (value != null && value !== defaultValue && typeof getSet.set === "function" && getSet.initialSet !== false) {
        const newValue = getSet.set(value, defaultValue, name);
        if (newValue !== value)
          genericComponent[name] = newValue;
      }
      this.genericGetSet(name, getSet);
    }, defaultValue);
  }
};
var destroyErrorMessage = `
If the component uses a controller that uses destroy() method, then the
component must have the following properties:
${// Don't expose internal code in production, and keep bundle smaller:
`preserveOnDisconnect and destroy` }
`.trim();

// src/proxyExports.ts
var proxyExports = (Class) => (...args) => {
  const ambientControllers = Controller.internals.retrieveParentControllers();
  const instance = new Class(...args);
  const initialExports = instance.exports;
  Controller.internals.setParentController(ambientControllers.at(-1));
  const internals = instance.component.manager.internals;
  internals.markExports(instance, initialExports);
  instance.watchExports((exports) => internals.markExports(instance, exports));
  Controller.internals.setAmbientChildController(instance);
  const hostCandidates = [instance.component, ...ambientControllers].reverse();
  return internals.trackKey(
    hostCandidates,
    (resolution) => resolution === void 0 ? void 0 : setProxy(instance, resolution.host, resolution.key, initialExports),
    initialExports
  );
};
function setProxy(controller, host, key, initialExports) {
  const genericHost = host;
  const controllerValueChanged = genericHost[key] !== controller.exports;
  const hostValueChanged = genericHost[key] !== initialExports;
  const controllerUpdatedExports = initialExports !== controller.exports;
  if (controllerValueChanged && !hostValueChanged && controllerUpdatedExports)
    genericHost[key] = controller.exports;
  controller.watchExports(() => {
    if (genericHost[key] === controller.exports)
      return;
    const manager = controller.component.manager;
    const isReadOnly = manager.internals.readonlyProps?.has(key) === true;
    if (isReadOnly)
      manager.bypassReadonly(() => {
        genericHost[key] = controller.exports;
      });
    else
      genericHost[key] = controller.exports;
  });
}

// src/functional.ts
var makeController = (constructor) => proxy(void 0, constructor);
var FunctionalController = class extends Controller {
  constructor(component, constructor) {
    super(component);
    const originalExports = this.exports;
    try {
      Controller.internals.setAmbientComponent(this.component);
      const value = constructor(this.component, this);
      const constructorChangedExports = this.exports !== originalExports;
      if (value instanceof Promise) {
        if (!constructorChangedExports)
          this.setProvisionalExports(value);
        const resolved = value.then((result) => {
          this.exports = result;
          super.catchUpLifecycle();
        }).catch((error) => {
          this._ready.reject(error);
          console.error(error);
        });
        this.onLoad(async () => await resolved);
      } else {
        if (!constructorChangedExports || value !== void 0)
          this.exports = value;
        queueMicrotask(() => super.catchUpLifecycle());
      }
    } catch (error) {
      this._ready.reject(error);
      console.error(error);
    }
  }
  /** Noop - will be called in the constructor instead */
  catchUpLifecycle() {
    return;
  }
};
var proxy = proxyExports(FunctionalController);

// src/load.ts
var load = (loader) => makeController(loader);
var AccessorController = class extends GenericController {
  constructor(component, _loadAccessor) {
    super(component);
    this._loadAccessor = _loadAccessor;
    this.reactiveUtils = this.component.reactiveUtils;
    this._watchedProperties = /* @__PURE__ */ new Set();
    this.setProvisionalExports(accessorInternals.makeGetterProxy(component, this._watchedProperties));
    this._originalReactiveUtilsIntegration = this.component.manager.internals.reactiveUtilsIntegration;
    this.component.manager.internals.reactiveUtilsIntegration = this.hostLoad.bind(this);
  }
  async hostLoad() {
    this._loadingPromise ?? (this._loadingPromise = safeAsyncCall(this._load.bind(this)));
    await this._loadingPromise;
  }
  async _load() {
    if (this.component.reactiveUtils === void 0)
      this.reactiveUtils = await importCoreReactiveUtils();
    else
      this.reactiveUtils = await this.use(this.component.reactiveUtils);
    const parameters = accessorInternals.gatherParameters(this, this._watchedProperties);
    this._instance = await this._createInstance(parameters);
    const members = getPropLikeMembers(this.component);
    const unwatchedMembers = members.filter((member) => !this._watchedProperties.has(member));
    if (unwatchedMembers.length > 0)
      await this._originalReactiveUtilsIntegration(unwatchedMembers);
    accessorInternals.watchComponentUpdates(this, this._instance, this._watchedProperties);
    accessorInternals.watchAccessorUpdates(this, this._instance, this._watchedProperties);
    this.exports = this._instance;
  }
  async _createInstance(parameters) {
    if (this._isAccessorConstructor(this._loadAccessor))
      return new this._loadAccessor(parameters);
    else
      return await this._loadAccessor(parameters);
  }
  _isAccessorConstructor(loader) {
    return "prototype" in loader && "declaredClass" in loader.prototype;
  }
};
var accessorInternals = {
  makeGetterProxy: (component, watchedProperties) => new Proxy(
    {},
    {
      /*
       * Without this, makeProvisionalValue() will throw on accessing
       * non-existent prop
       */
      has: (target, prop) => typeof prop === "string" || prop in target,
      get: (target, prop) => {
        const value = Reflect.get(target, prop);
        if (typeof prop === "symbol" || prop in Promise.prototype)
          return value;
        if (prop in target)
          return value;
        watchedProperties.add(prop);
        return value;
      }
    }
  ),
  // Update Accessor on component prop change
  watchComponentUpdates(controller, instance, watchedProperties) {
    const readonlyProps = findReadOnlyAccessorProps(instance);
    const getter = (_value, propertyName) => instance[propertyName];
    const setter = (newValue, _oldValue, propertyName) => {
      if (instance[propertyName] === newValue)
        return newValue;
      instance[propertyName] = newValue;
      return instance[propertyName];
    };
    const { component } = controller;
    watchedProperties.forEach((propertyName) => {
      if (!readonlyProps.has(propertyName))
        component[propertyName] = component[propertyName] || instance[propertyName];
      controller.internals.accessorGetter[propertyName] = getter;
      controller.internals.accessorSetter[propertyName] = setter;
    });
  },
  // Update component on Accessor prop change
  watchAccessorUpdates(controller, instance, watchedProperties) {
    const { component } = controller;
    component.manager.bypassGetter(
      () => watchedProperties.forEach((property) => {
        const domValue = component[property];
        const modelValue = instance[property];
        if (domValue != null && modelValue !== domValue)
          instance[property] = domValue;
      })
    );
    controller.onLifecycle(
      () => Array.from(
        watchedProperties,
        (aliasName) => controller.reactiveUtils.watch(
          () => instance[aliasName],
          () => watchCallback(component, instance, aliasName),
          { initial: true }
        )
      )
    );
  },
  gatherParameters(controller, watchedProperties) {
    const { component } = controller;
    const data = Object.fromEntries(
      Array.from(watchedProperties, (key) => [key, component[key]]).filter(
        ([, value]) => value !== void 0
      )
    );
    return data ;
  }
};
function findReadOnlyAccessorProps(instance) {
  const accessor = instance;
  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});
  return new Set(
    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)
  );
}
function watchCallback(component, instance, property) {
  const newValue = instance[property];
  component[property] = newValue;
}
function useT9n({
  blocking = false,
  name
} = {}) {
  return makeController((component, controller) => {
    controller.onLifecycle(
      () => startLocaleObserver(
        component.el,
        getAssetPath("./assets"),
        ({ t9nLocale, t9nStrings, lang }) => {
          controller.exports = { ...t9nStrings, _lang: lang, _t9nLocale: t9nLocale };
          const label = t9nStrings.componentLabel ?? t9nStrings.widgetLabel;
          if (typeof label === "string" && "label" in component && component.label == null)
            component.label ?? (component.label = label);
        },
        name
      )
    );
    if (blocking)
      return controller.ready;
    const locale = getElementLocales(component.el);
    return { _lang: locale.lang, _t9nLocale: locale.t9nLocale };
  });
}

// src/usePropertyChange.ts
var usePropertyChange = (_component) => propertyChangeController;
var eventName = "arcgisPropertyChange";
var propertyChangeController = (...toWatch) => makeController((component, controller) => {
  const eventEmitter = component[eventName];
  controller.onLoad(
    () => controller.onLifecycle(
      () => toWatch.map(
        (name) => (
          // Casting to 'el' to simplify dynamic prop name typing
          component.manager.watch(name, () => eventEmitter.emit({ name }))
        )
      )
    )
  );
  return eventEmitter;
});

export { AccessorController as A, accessorInternals as a, usePropertyChange as b, useT9n as c, load as l, proxyExports as p, useControllerManager as u };
