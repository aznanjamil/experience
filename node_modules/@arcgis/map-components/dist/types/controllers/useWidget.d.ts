import type { BaseComponent, CovariantEventEmitter } from "@arcgis/components-controllers";
import { AccessorController } from "@arcgis/components-controllers";
import type { Nil } from "@arcgis/components-utils";
import type { ArcGISMapView, ArcGISSceneView } from "../components/types";
import type { ArcgisReferenceElement } from "../utils/component-utils";
import type { EventEmitter } from "../stencil-public-runtime";
type Requires<Props, Widget extends WidgetInstance> = BaseComponent & Pick<Widget, keyof Props & keyof Widget> & Uses<Widget>;
type WidgetInstance = __esri.Widget & {
    state?: string;
    viewModel?: __esri.Accessor & {
        state?: string;
        view?: ArcGISMapView | ArcGISSceneView | Nil;
    };
    view?: ArcGISMapView | ArcGISSceneView | Nil;
    visibleElements?: Record<never, unknown>;
};
type Uses<Widget extends WidgetInstance> = {
    reactiveUtils?: typeof __esri.reactiveUtils;
    state?: Exclude<Widget["viewModel"], Nil>["state"] | Widget["state"];
    viewModel?: Widget["viewModel"];
    icon: Nil | string;
    label: Nil | string;
    view?: ArcGISMapView | Nil;
    referenceElement: ArcgisReferenceElement | string | undefined;
    position: string;
    arcgisReady: EventEmitter<never>;
    arcgisPropertyChange: CovariantEventEmitter<{
        name: string;
    }>;
    el: HTMLElement & {
        childElem?: HTMLElement;
    };
    childElem?: HTMLElement;
};
/**
 * A controller for a wrapped JS API Widget
 * - loads the widget
 * - initializes the widget with the component's properties
 * - does two-way binding between widget and component properties
 * - re-emits the widgets's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/map-components/src/controllers/useWidget.md
 */
export declare const makeWidgetController: <Props, Widget extends WidgetInstance, OmitProps extends string = never>(loadWidget: (props: Props) => Promise<Widget>, _options?: {
    /**
     * Don't expose the following Widget's properties on the component.
     * You can also bind the property to \@State rather than \@Prop if you
     * wish to use it internally only:
     * @example
     * \@State() timeZone = this.widget.timeZone;
     */
    omitProps: OmitProps[];
} | undefined) => (component: Requires<Omit<Props, "id" | "view" | "container" | "visible" | "visibleElements" | OmitProps>, Widget>) => Widget;
export declare class WidgetController<Props, Widget extends WidgetInstance> extends AccessorController<Props, Widget, Uses<Widget>> {
    private _watchedViewModelProperties;
    private _watchedVisibleElementsProperties;
    constructor(component: Requires<Props, Widget> & Uses<Widget>, _loadAccessor: (props: Props) => Promise<Widget>);
    hostConnected(): void;
    hostLoad(): Promise<void>;
    _updateWidgetVisibleElement(propertyChain: readonly string[], propValue: unknown, shouldFlip: boolean): void;
    hostLoaded(): void;
    private _watchMetaProperties;
    private _reEmitWidgetEvents;
    hostDisconnected(): void;
    private _makeVisibleElementsBinder;
    private _makeRecursiveProxy;
}
export {};
