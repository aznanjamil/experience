/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */
import{a as t,f as e}from"./p-db9a72ae.js";import{l as s,m as i,i as o}from"./p-9bad2661.js";var n=(63,t=>Object.entries(t.manager.internals.members??{}).filter((([t,[e]])=>0!=(63&e))).map((([t])=>t))),r=(t,e)=>t.manager.internals.members?.[e]?.[0];function h(t,e){const s=r(t,e);return void 0===s?void 0:32&s?"state":"prop"}var c=class{constructor(){this.resolve=()=>{},this.reject=()=>{},this.promise=new Promise(((t,e)=>{this.resolve=t,this.reject=e}))}};var a={};function l(t){try{return t?.()}catch(e){console.error(e,t)}}async function u(t){try{return await t()}catch(e){console.error(e,t)}}var d=new Set(["ar","bg","bs","ca","cs","da","de","el","en","es","et","fi","fr","he","hr","hu","id","it","ja","ko","lt","lv","nl","nb","pl","pt-BR","pt-PT","ro","ru","sk","sl","sr","sv","th","tr","uk","vi","zh-CN","zh-HK","zh-TW"]),p="en";async function f(t,e,s=""){const i=`${e}/${s}`,o=`${i}${t}.json`;return y[o]??(y[o]=v(t,i)),await y[o]}var y={};async function v(t,e){const s=`${e}${t}.json`;try{const t=await fetch(s);if(t.ok)return await t.json()}catch(t){return console.error(t),m}return t===p?m:await v(p,e)}var m=new Proxy({},{get:(t,e)=>{return(s=e.toString().replaceAll(/([a-z])([A-Z])/gu,"$1 $2")).charAt(0).toUpperCase()+s.slice(1);var s}});function g(t){const e=function(t,e,s){const i=function(t,e){let s=t;for(;s;){const t=s.closest(e);if(t)return t;const i=s.getRootNode();if(i===document)return null;s=i.host}return null}(t,`[${e}]`);return i?.getAttribute(e)??s}(t,"lang",navigator.language||p);if(d.has(e))return{lang:e,t9nLocale:e};const s=e.slice(0,2);return{lang:e,t9nLocale:d.has(s)?s:p}}function w(t,e,s,i){let o;const n=()=>{(async function(t,e,s=t.tagName.toLowerCase().replace("arcgis-","")){const{lang:i,t9nLocale:o}=g(t),n=`${e}/${s}/t9n`,r=`${s}.t9n.`;return{lang:i,t9nLocale:o,t9nStrings:await f(o,n,r)}})(t,e,i).then((t=>{o?.lang===t.lang&&o.t9nLocale===t.t9nLocale&&o.t9nStrings===t.t9nStrings||s(t),o=t})).catch(console.error)};return n(),function(t,e,s){const{subscribe:i}=function(t){const e=t.join(","),s=a[e];if(void 0!==s)return s;const i=new Set,o=new MutationObserver((t=>i.forEach((e=>e(t)))));o.observe(document.documentElement,{attributes:!0,attributeFilter:t,subtree:!0});const n={subscribe:t=>(i.add(t),{remove:()=>{i.delete(t),0===i.size&&(o.disconnect(),a[e]=void 0)}})};return a[e]=n,n}(e);return i((e=>{const i=e.some((e=>function(t,e){let s=t;for(;s;){if(s===e)return!0;if(!s.parentNode)return!1;s=s.parentNode instanceof ShadowRoot?s.parentNode.host:s.parentNode}return!1}(t,e.target)));i&&s()}))}(t,["lang"],n)}var b,C=Symbol("controller"),k=["The value you passed is not a controller and not a controller exports. If ","your controller exports a literal value, try making your controller export ","an object instead"].join(""),S=class t{constructor(e){this._ready=new c,this._lifecycleDisconnected=[],this.connectedCalled=!1,this.willLoadCalled=!1,this.didLoadCalled=!1,this[b]=!0,this.ready=this._ready.promise,this._exports=x(this),this._exportWatchers=new Set;const s=function(t){if("addController"in t)return t;throw new Error("Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line")}(e??t.internals.retrieveComponent(new.target.name));Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:s}),this.component.addController(this);const i=this.component.manager;this.connected=i?.connected,this.internals=i?.internals,t.internals.setParentController(this),"hostDestroy"in this&&this.component.manager.ensureHasDestroy(),void 0!==i&&queueMicrotask((()=>this.catchUpLifecycle()));const o=this;this._callbacks={hostConnected:"hostConnected"in this?[()=>o.hostConnected?.()]:[],hostDisconnected:"hostDisconnected"in this?[()=>o.hostDisconnected?.()]:[],hostLoad:"hostLoad"in this?[()=>o.hostLoad?.()]:[],hostLoaded:"hostLoaded"in this?[()=>o.hostLoaded?.()]:[],hostRender:"hostRender"in this?[()=>o.hostRender?.()]:[],hostRendered:"hostRendered"in this?[()=>o.hostRendered?.()]:[],hostUpdate:"hostUpdate"in this?[()=>o.hostUpdate?.()]:[],hostUpdated:"hostUpdated"in this?[()=>o.hostUpdated?.()]:[],hostDestroy:"hostDestroy"in this?[()=>o.hostDestroy?.()]:[],hostLifecycle:"hostLifecycle"in this?[()=>o.hostLifecycle?.()]:[]}}catchUpLifecycle(){this.connectedCalled||(this.triggerConnected(),!this.component.manager.willLoadCalled||this.triggerLoad().then((()=>{!this.component.manager.didLoadCalled||this.triggerLoaded()})).catch(console.error))}get exports(){return this._exports}set exports(t){this._exports!==t&&(this._exports=t,this.connectedCalled&&this.component.requestUpdate(),this._exportWatchers.forEach((e=>e(t)))),this._ready.resolve(t)}setProvisionalExports(t){this._exports=x(t),this._exportWatchers.forEach((t=>t(this._exports)))}watchExports(t){const e=e=>l((()=>t(e)));return this._exportWatchers.add(e),()=>{this._exportWatchers.delete(e)}}get use(){return t.internals.setAmbientComponent(this.component),t.internals.use}get useRef(){return t.internals.setAmbientComponent(this.component),t.internals.useRef}bypassSetter(e){t.internals.shouldBypassSetter=!0;try{return e()}finally{t.internals.shouldBypassSetter=!1}}bypassReadonly(e){t.internals.shouldBypassReadonly=!0;try{return e()}finally{t.internals.shouldBypassReadonly=!1}}bypassGetter(e){t.internals.shouldBypassGetter=!0;try{return e()}finally{t.internals.shouldBypassGetter=!1}}dynamicGetSet(t,e){this.genericGetSet(t,e)}genericGetSet(t,e){var s,i;const o=e;void 0!==o.get&&((s=this.internals.getters)[t]??(s[t]=[]),this.internals.getters[t].unshift(o.get)),void 0!==o.set&&((i=this.internals.setters)[t]??(i[t]=[]),this.internals.setters[t].unshift(o.set))}watch(t,e){var s;if(void 0===r(this.component,t))throw new Error(`Trying to watch a non-@Prop, non-@State property "${t}". Either convert it into a @State() or use manager.getSet/dynamicGetSet`);(s=this.internals.allWatchers)[t]??(s[t]=[]);const i=this.internals.allWatchers[t],o=e,n=(t,e,s)=>l((()=>o(t,e,s)));return i.push(n),()=>{const t=i.indexOf(n);-1!==t&&i.splice(t,1)}}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onRender(t){this._callbacks.hostRender.push(t)}onRendered(t){this._callbacks.hostRendered.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this.component.manager.ensureHasDestroy(),this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){this._callbacks.hostConnected.forEach(l),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){this._callbacks.hostDisconnected.forEach(l),this._lifecycleDisconnected.forEach(l),this._lifecycleDisconnected=[]}async triggerLoad(){this.willLoadCalled||(this.willLoadCalled=!0,this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(u)),this._ready.resolve(this._exports))}triggerLoaded(){this.didLoadCalled||(this._callbacks.hostLoaded.forEach(l),this.didLoadCalled=!0)}async triggerRender(){this._callbacks.hostRender.length>0&&await Promise.allSettled(this._callbacks.hostRender.map(u))}triggerRendered(){this._callbacks.hostRendered.forEach(l)}async triggerUpdate(){this._callbacks.hostUpdate.length>0&&await Promise.allSettled(this._callbacks.hostUpdate.map(u))}triggerUpdated(){this._callbacks.hostUpdated.forEach(l)}triggerDestroy(){this._callbacks.hostDestroy.forEach(l)}triggerLifecycle(){this._callbacks.hostLifecycle.forEach((t=>this._callLifecycle(t)))}_callLifecycle(t){const e=l(t);(Array.isArray(e)?e:[e]).forEach((t=>{"function"==typeof t?this._lifecycleDisconnected.push(t):"object"==typeof t&&"function"==typeof t.remove&&this._lifecycleDisconnected.push(t.remove)}))}};b=C,S.internals=new class{constructor(){this._ambientControllers=[],this.use=async(t,e)=>{const s=this._useRefSync(t);if(void 0===s){if("function"==typeof e){const t=new Error(`Unable to resolve a controller from the provided value, so can't watch it's exports. ${k}`);console.error(t)}return t}if(await s.ready,"function"==typeof e){if(void 0===s.watchExports)throw new Error("The controller must implement watchExports method to support watching exports");const t=s.watchExports((s=>e(s,t)))}return s.exports},this.useRef=async t=>{const e=this._useRefSync(t);if(void 0===e)throw new Error(`Unable to resolve a controller from the provided value. ${k}`);return await e.ready,e},this.shouldBypassSetter=!1,this.shouldBypassGetter=!1,this.shouldBypassReadonly=!1,this.elementToInstance=new WeakMap}setAmbientComponent(t){this._ambientComponent!==t&&(this._ambientComponent=t,queueMicrotask((()=>{this._ambientComponent===t&&(this._ambientComponent=void 0)})))}retrieveComponent(t){if(void 0===this._ambientComponent)throw new Error([`Unable to find out which component ${t||"this"} controller `,"belongs to. This might happen if you tried to create a controller ","outside the component. If so, please wrap your controller ","definition in an arrow function, ","`const myController = ()=>makeController(...);` and call that","function inside the component `my = myController();`, or ","define your controller using makeGenericController/GenericController ","instead.\n","If you wish to use a controller inside an async controller, ","make sure you are using controller.use.\n","You might also have multiple instances of Controllers loaded"].join("\n"));return this._ambientComponent}setParentController(t){if(void 0===t)return void(this._ambientControllers=[]);const e=this._ambientControllers.indexOf(t);this._ambientControllers=-1===e?[...this._ambientControllers,t]:this._ambientControllers.slice(0,e+1),queueMicrotask((()=>{this._ambientControllers=[]}))}retrieveParentControllers(){return this._ambientControllers}setAmbientChildController(t){this._ambientChildController!==t&&(this._ambientChildController=t,queueMicrotask((()=>{this._ambientChildController===t&&(this._ambientChildController=void 0)})))}retrieveAmbientChildController(){const t=this._ambientChildController;return this._ambientChildController=void 0,t}_useRefSync(t){const e=this.retrieveAmbientChildController();if(void 0!==e)return e;const s=L.internals.retrieveComponent().manager.internals.resolveExports(t);return void 0!==s?s:(t=>"object"==typeof t&&null!==t&&(C in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t)?t:void 0}};var L=S,j=class extends L{constructor(t){super(t)}watch(t,e){return super.watch(t,e)}dynamicGetSet(t,e){super.genericGetSet(t,e)}};function x(t){if("object"!=typeof t&&"function"!=typeof t||null===t)return t;const e=new Proxy(t,{get(t,s,i){if(!$.has(s)||!(s in t)||t[s]!==e)return s in t||s in Promise.prototype||"symbol"==typeof s?"function"==typeof t?t[s]:Reflect.get(t,s,i):void console.error(`Trying to access "${s.toString()}" on the controller before it's loaded. ${P}`)},set:(t,e,s,i)=>(console.error(`Trying to set "${e.toString()}" on the controller before it's loaded. ${P}`),Reflect.set(t,e,s,i))});return e}var $=new Set(["exports","_exports"]),P=["This might be the case if you are trying to access an async controller in ","connectedCallback(). Or, if you are using it inside of ","componentWillLoad()/another controller without controller.use. Example correct ","usage:\n","makeController(async (component, controller)=>{ await controller.use(someOtherController); });"].join("");function U(t,e,s){const i=Object.keys(t),o=i.length;void 0===D&&queueMicrotask(O),D??(D=new Map);let n=D.get(t);return void 0===n&&(n={callbacks:[],keyCount:o},D.set(t,n)),n.keyCount!==o&&(n.callbacks.forEach((t=>t(i))),n.callbacks=[],n.keyCount=o),n.callbacks.push((i=>{const n=i[o];var r;r=void 0===n?void 0:t[n]===s?n:void 0,l((()=>e(r)))})),s}var D=void 0;function O(){Array.from(D?.entries()??[]).forEach((([t,{callbacks:e}])=>{const s=Object.keys(t);e.forEach((t=>t(s)))})),D=void 0}var R=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.trackKey=(t,e,s)=>{const i=Array.isArray(t)?t:[t];let o=i.length+1;const n=t=>{o-=1,void 0!==t&&(o=0),0===o&&e(t)};return i.forEach((t=>this.component.manager.trackPropertyKey(t,(e=>n(void 0===e?void 0:{key:e,host:t,type:"property",domValue:void 0})),s))),this.component.manager.trackPropKey(((t,e)=>{const s=void 0===t?void 0:h(this.component,t);n(void 0===t?void 0:{key:t,host:this.component,type:s??"prop",domValue:"prop"===s?e:void 0})}),s),s},this.trackPropKey=(t,e,s=!1)=>(this._trackedValue!==A&&this._trackedValue!==e&&this._firePropertyTrackers(void 0,void 0,void 0),0===this._keyTrackers.length&&queueMicrotask((()=>this._firePropertyTrackers(void 0,void 0,void 0))),this._trackedValue=e,this._keyTrackers.push(((i,o,n)=>l((()=>t(e===o||s?i:void 0,n))))),e),this._trackedValue=A,this._keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this._exports=new WeakMap,Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:t})}_firePropertyTrackers(t,e,s){const i=this._keyTrackers;this._trackedValue=A,this._keyTrackers=[],i.forEach((i=>i(t,e,s)))}getSetProxy(t,e,s){const i=Object.getPrototypeOf(this.component);this._getSetProxy(i,t,e,s,"class");const o=Object.getPrototypeOf(this.component.el);i!==o&&this._getSetProxy(o,t,e,s,"html")}_getSetProxy(t,e,s,i,o){const n=this.component,h=r(n,e),c=Object.getOwnPropertyDescriptor(t,e),a="html"===o;if(void 0===c?.set||void 0===c.get){if(void 0!==c&&"value"in c)throw new Error(`getSet() should only be used on Stencil's @Prop and @State properties. For internal component properties, use regular get/set syntax. Tried to use it on "${e}" in ${n.el.tagName}`);if(a)return;throw new Error(`Unable to find "${e}" property on the ${n.el.tagName} component`)}const{get:l,set:u}=c,d=!(E in l)&&s,p=!(E in u)&&i;if(!d&&!p)return;const f=d?function(){let t=l.call(this);const s=L.internals.elementToInstance.get(this);if(L.internals.shouldBypassGetter||void 0===s)return t;const i=s.manager.internals;t=i.accessorGetter[e](t,e);const o=i.getters[e]??_;for(let s=0;s<o.length;s++)t=o[s](t,e);return t}:l,y=p?function(t){const s=l.call(this);let i=function(t,e=8){return null==t||"object"==typeof t||"function"==typeof t?t:0!=(4&e)?"false"!==t&&(""===t||!!t):0!=(2&e)?Number.parseFloat(t.toString()):0!=(1&e)?String(t):t}(t,h);const o=L.internals.elementToInstance.get(this);if(void 0===o)return void u.call(this,t);const n=o.manager.internals;if(i===s)u.call(this,t);else{const t=L.internals.shouldBypassSetter?_:n.setters[e]??_;for(let o=0;o<t.length;o++)i=t[o](i,s,e);i=n.accessorSetter[e](i,s,e),u.call(this,i),i!==s&&n.enabledWatchers[e]?.forEach((t=>t(i,s,e)))}n._keyTrackers.length>0&&n?._firePropertyTrackers(e,t,s)}:u;d&&Object.defineProperty(f,E,{value:!0}),p&&Object.defineProperty(y,E,{value:!0}),Object.defineProperty(t,e,{...c,get:f,set:y})}markExports(t,e){("object"==typeof e&&null!==e||"function"==typeof e)&&this._exports.set(e,t)}resolveExports(t){return"object"==typeof t&&null!==t||"function"==typeof t?this._exports.get(t):void 0}},_=[],E=Symbol("controllersCustomAccessor"),A=Symbol("nothing"),M=Promise.all([s(),i()]),T=t=>t,W=t=>new q(t),q=class extends j{constructor(t){const s=new Set;var i;i=t,Object.entries({addController:t=>{s.add(t)},removeController:t=>{s.delete(t)},requestUpdate:()=>e(t)}).forEach((([t,e])=>{if(t in i)throw new Error(`Unable to extend object because property "${t}" is already defined`);i[t]=e})),super(t),this._connected=new c,this.internals=new R(this.component),this.connected=this._connected.promise,this.hasDestroy=!1,this.destroyed=!1,this._updatePromise=new c,this._originalLifecycles={},this.trackPropertyKey=U,this.trackPropKey=this.internals.trackPropKey,this.trackKey=this.internals.trackKey,this._readonlySetter=(t,s,i)=>{if(L.internals.shouldBypassReadonly)return t;throw"prop"===h(this.component,i)&&e(this.component),new Error(`Cannot assign to read-only property "${i}" of ${this.component.el.tagName.toLowerCase()}. Trying to assign "${String(t)}"`)},this.devOnlySetPersistentControllerData=void 0,this.devOnlyGetPersistentControllerData=void 0,this.component.manager=this,function(t){const e=t.constructor,s=e.__registerControllers?.(t)??void 0;if(e.__registerControllers=void 0,"object"!=typeof s)throw new Error("Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config.");t.manager.internals.members=s}(t),this._controllers=s,this.exports=void 0,this.hasDestroy="preserveOnDisconnect"in this.component&&"function"==typeof this.component.destroy,this.hasDestroy&&this.watch("preserveOnDisconnect",(()=>this._preserveOnDisconnectWatcher())),this._bindLifecycleMethods(),Object.defineProperty(t,"updateComplete",{get:async()=>await this._updatePromise.promise}),this.internals.reactiveUtilsIntegration=function(t){const e=n(t),s=t.manager.internals;return e.forEach((t=>{s.accessorGetter[t]=T,s.accessorSetter[t]=T,s.getSetProxy(t,!0,!0)})),async(i=e)=>{const[o,{subclass:n,property:r}]=await M;class h extends o{}const c=(t,e)=>l[e];function a(t,e,s){return void 0!==l&&(l[s]=t),t}t.manager.bypassGetter((()=>i.forEach((e=>{s.accessorGetter[e]=c,s.accessorSetter[e]=a,r({value:t[e]})(h.prototype,e)}))));const l=new(n(t.el.tagName)(h))}}(this.component),L.internals.setParentController(void 0),L.internals.setAmbientComponent(t),L.internals.elementToInstance.set(t.el,t),L.internals.elementToInstance.set(t,t)}_bindLifecycleMethods(){const t=this.component;this._originalLifecycles={connectedCallback:t.connectedCallback,disconnectedCallback:t.disconnectedCallback,componentWillLoad:t.componentWillLoad,componentDidLoad:t.componentDidLoad,componentWillRender:t.componentWillRender,componentDidRender:t.componentDidRender,componentWillUpdate:t.componentWillUpdate,componentDidUpdate:t.componentDidUpdate,destroy:t.destroy},t.connectedCallback=this._connectedCallback.bind(this),t.disconnectedCallback=this._disconnectedCallback.bind(this),t.componentWillLoad=this._componentWillLoad.bind(this),t.componentDidLoad=this._componentDidLoad.bind(this),t.componentWillRender=this._componentWillRender.bind(this),t.componentDidRender=this._componentDidRender.bind(this),t.componentWillUpdate=this._componentWillUpdate.bind(this),t.componentDidUpdate=this._componentDidUpdate.bind(this),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}ensureHasDestroy(){if(!this.hasDestroy)throw new Error(G)}_connectedCallback(){if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error(`The ${t} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the preserveOnDisconnect prop.`)}this.internals.enabledWatchers=this.internals.allWatchers,O(),this._connected.resolve(),this._controllers.forEach((t=>"triggerConnected"in t?t.triggerConnected():l((()=>t.hostConnected?.())))),this._originalLifecycles.connectedCallback?.call(this.component)}_disconnectedCallback(){this.destroyed||(this._controllers.forEach((t=>"triggerDisconnected"in t?t.triggerDisconnected():l((()=>t.hostDisconnected?.())))),this._originalLifecycles.disconnectedCallback?.call(this.component),this.hasDestroy&&this._preserveOnDisconnectWatcher())}async _componentWillLoad(){await this.internals.reactiveUtilsIntegration(),await Promise.allSettled(Array.from(this._controllers,(async t=>"triggerLoad"in t?await t.triggerLoad():await u((async()=>await(t.hostLoad?.())))))),await(this._originalLifecycles.componentWillLoad?.call(this.component))}_componentDidLoad(){this._controllers.forEach((t=>"triggerLoaded"in t?t.triggerLoaded():l((()=>t.hostLoaded?.())))),this._originalLifecycles.componentDidLoad?.call(this.component)}async _componentWillRender(){await Promise.allSettled(Array.from(this._controllers,(async t=>"triggerRender"in t?await t.triggerRender():await u((async()=>await(t.hostRender?.())))))),await(this._originalLifecycles.componentWillRender?.call(this.component))}_componentDidRender(){this._controllers.forEach((t=>"triggerRendered"in t?t.triggerRendered():l((()=>t.hostRendered?.())))),this._originalLifecycles.componentDidRender?.call(this.component)}async _componentWillUpdate(){await Promise.allSettled(Array.from(this._controllers,(async t=>"triggerUpdate"in t?await t.triggerUpdate():await u((async()=>await(t.hostUpdate?.())))))),await(this._originalLifecycles.componentWillUpdate?.call(this.component))}_componentDidUpdate(){this._controllers.forEach((t=>"triggerUpdated"in t?t.triggerUpdated():l((()=>t.hostUpdated?.())))),this._originalLifecycles.componentDidUpdate?.call(this.component);const t=this._updatePromise;this._updatePromise=new c,t.resolve(!0)}async destroy(){this.ensureHasDestroy(),this.destroyed||(this.component.el.isConnected&&(this.hasDestroy=!1,this.component.el.remove(),this.hasDestroy=!0),this.destroyed=!0,this._controllers.forEach((t=>"triggerDestroy"in t?t.triggerDestroy():l((()=>t.hostDestroy?.())))),await(this._originalLifecycles.destroy?.call(this.component)))}_preserveOnDisconnectWatcher(){this.component.el.isConnected||this.component.preserveOnDisconnect||this.destroy().catch(console.error)}readonly(t){return this.getSet(t,{set:this._readonlySetter})}getSet(t,e){return this.component.manager.trackPropKey((s=>{var i;if(void 0===s)throw new Error("Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})");e.set===this._readonlySetter&&((i=this.internals).readonlyProps??(i.readonlyProps=new Set),this.internals.readonlyProps.add(s));const o=this.component,n=o[s];if(null!=n&&n!==t&&"function"==typeof e.set&&!1!==e.initialSet){const i=e.set(n,t,s);i!==n&&(o[s]=i)}this.genericGetSet(s,e)}),t)}},G="\nIf the component uses a controller that uses destroy() method, then the\ncomponent must have the following properties:\npreserveOnDisconnect and destroy\n".trim(),I=t=>(...e)=>{const s=L.internals.retrieveParentControllers(),i=new t(...e),o=i.exports;L.internals.setParentController(s.at(-1));const n=i.component.manager.internals;n.markExports(i,o),i.watchExports((t=>n.markExports(i,t))),L.internals.setAmbientChildController(i);const r=[i.component,...s].reverse();return n.trackKey(r,(t=>void 0===t?void 0:function(t,e,s,i){const o=e;o[s]!==t.exports&&!(o[s]!==i)&&i!==t.exports&&(o[s]=t.exports),t.watchExports((()=>{if(o[s]===t.exports)return;const e=t.component.manager;!0===e.internals.readonlyProps?.has(s)?e.bypassReadonly((()=>{o[s]=t.exports})):o[s]=t.exports}))}(i,t.host,t.key,o)),o)},z=t=>F(void 0,t),F=I(class extends L{constructor(t,e){super(t);const s=this.exports;try{L.internals.setAmbientComponent(this.component);const t=e(this.component,this),i=this.exports!==s;if(t instanceof Promise){i||this.setProvisionalExports(t);const e=t.then((t=>{this.exports=t,super.catchUpLifecycle()})).catch((t=>{this._ready.reject(t),console.error(t)}));this.onLoad((async()=>await e))}else i&&void 0===t||(this.exports=t),queueMicrotask((()=>super.catchUpLifecycle()))}catch(t){this._ready.reject(t),console.error(t)}}catchUpLifecycle(){}}),H=t=>z(t),V=class extends j{constructor(t,e){super(t),this._loadAccessor=e,this.reactiveUtils=this.component.reactiveUtils,this._watchedProperties=new Set,this.setProvisionalExports(N.makeGetterProxy(t,this._watchedProperties)),this._originalReactiveUtilsIntegration=this.component.manager.internals.reactiveUtilsIntegration,this.component.manager.internals.reactiveUtilsIntegration=this.hostLoad.bind(this)}async hostLoad(){this._loadingPromise??(this._loadingPromise=u(this._load.bind(this))),await this._loadingPromise}async _load(){this.reactiveUtils=void 0===this.component.reactiveUtils?await o():await this.use(this.component.reactiveUtils);const t=N.gatherParameters(this,this._watchedProperties);this._instance=await this._createInstance(t);const e=n(this.component).filter((t=>!this._watchedProperties.has(t)));e.length>0&&await this._originalReactiveUtilsIntegration(e),N.watchComponentUpdates(this,this._instance,this._watchedProperties),N.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance}async _createInstance(t){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(t):await this._loadAccessor(t)}_isAccessorConstructor(t){return"prototype"in t&&"declaredClass"in t.prototype}},N={makeGetterProxy:(t,e)=>new Proxy({},{has:(t,e)=>"string"==typeof e||e in t,get:(t,s)=>{const i=Reflect.get(t,s);return"symbol"==typeof s||s in Promise.prototype||s in t||e.add(s),i}}),watchComponentUpdates(t,e,s){const i=function(t){const e=t,s=Object.entries(e.__accessor__?.metadata??{});return new Set(s.filter((([t,e])=>!0===e?.readOnly)).map((([t])=>t)))}(e),o=(t,s)=>e[s],n=(t,s,i)=>e[i]===t?t:(e[i]=t,e[i]),{component:r}=t;s.forEach((s=>{i.has(s)||(r[s]=r[s]||e[s]),t.internals.accessorGetter[s]=o,t.internals.accessorSetter[s]=n}))},watchAccessorUpdates(t,e,s){const{component:i}=t;i.manager.bypassGetter((()=>s.forEach((t=>{const s=i[t];null!=s&&e[t]!==s&&(e[t]=s)})))),t.onLifecycle((()=>Array.from(s,(s=>t.reactiveUtils.watch((()=>e[s]),(()=>function(t,e,s){t[s]=e[s]}(i,e,s)),{initial:!0})))))},gatherParameters(t,e){const{component:s}=t;return Object.fromEntries(Array.from(e,(t=>[t,s[t]])).filter((([,t])=>void 0!==t)))}};function B({blocking:e=!1,name:s}={}){return z(((i,o)=>{if(o.onLifecycle((()=>w(i.el,t("./assets"),(({t9nLocale:t,t9nStrings:e,lang:s})=>{o.exports={...e,_lang:s,_t9nLocale:t};const n=e.componentLabel??e.widgetLabel;"string"==typeof n&&"label"in i&&null==i.label&&(i.label??(i.label=n))}),s))),e)return o.ready;const n=g(i.el);return{_lang:n.lang,_t9nLocale:n.t9nLocale}}))}var K=()=>Y,Y=(...t)=>z(((e,s)=>{const i=e.arcgisPropertyChange;return s.onLoad((()=>s.onLifecycle((()=>t.map((t=>e.manager.watch(t,(()=>i.emit({name:t}))))))))),i}));export{V as A,N as a,K as b,B as c,H as l,I as p,W as u}