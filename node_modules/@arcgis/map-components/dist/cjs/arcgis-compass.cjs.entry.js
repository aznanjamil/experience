/*!
 * All material copyright Esri, All Rights Reserved, unless otherwise specified.
 * See https://js.arcgis.com/4.30/esri/copyright.txt for details.
 * v4.30.0-next.37
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-dcd70450.js');
const index$2 = require('./index-98f3aa83.js');
const chunkWQTCUXBS = require('./chunk-WQTCUXBS-3a2e1235.js');
const index$1 = require('./index-dbd85b3f.js');
const componentUtils = require('./component-utils-98a2050c.js');

// FIXME: auto-destroy widget?
/**
 * A controller for a wrapped JS API Widget
 * - loads the widget
 * - initializes the widget with the component's properties
 * - does two-way binding between widget and component properties
 * - re-emits the widgets's events on the component
 * - type-checks everything âœ¨
 *
 * Documentation:
 * https://devtopia.esri.com/WebGIS/arcgis-web-components/blob/main/packages/map-components/src/controllers/useWidget.md
 */
const makeWidgetController = (loadWidget, _options) => (component) => proxy(component, loadWidget);
class WidgetController extends chunkWQTCUXBS.AccessorController {
    constructor(component, _loadAccessor) {
        super(component, _loadAccessor);
        this._watchedViewModelProperties = new Set();
        this._watchedVisibleElementsProperties = {};
        Object.defineProperty(this.exports, "viewModel", {
            value: chunkWQTCUXBS.accessorInternals.makeGetterProxy(component, this._watchedViewModelProperties),
        });
        Object.defineProperty(this.exports, "visibleElements", {
            value: this._makeVisibleElementsBinder(),
        });
    }
    hostConnected() {
        if (this.component.manager.didLoadCalled)
            componentUtils.checkForView(this.component);
    }
    async hostLoad() {
        this.component.render = () => index.h("div", null);
        /*
         * "viewModel" property might not have a @State(), so two-way binding might
         * not work (and probably one way is fine)
         */
        this._watchedProperties.delete("viewModel");
        await super.hostLoad();
        this._watchMetaProperties();
        this._reEmitWidgetEvents();
        // Do one way watching for viewModel property
        this.onLifecycle(() => this.reactiveUtils.watch(() => this._instance.viewModel, (newViewModel) => {
            this.component.viewModel = newViewModel;
        }, { initial: true }));
        const viewModel = this._instance.viewModel;
        if (typeof viewModel === "object") {
            chunkWQTCUXBS.accessorInternals.watchComponentUpdates(this, viewModel, this._watchedViewModelProperties);
            chunkWQTCUXBS.accessorInternals.watchAccessorUpdates(this, viewModel, this._watchedViewModelProperties);
            const parameters = chunkWQTCUXBS.accessorInternals.gatherParameters(this, this._watchedViewModelProperties);
            viewModel.set(parameters);
        }
        else if (this._watchedViewModelProperties.size > 0)
            throw new Error(`The widget does not have a viewModel to bind to. Tried to bind the following properties: ${Array.from(this._watchedViewModelProperties).join(", ")}`);
        const visibleElements = Object.entries(this._watchedVisibleElementsProperties);
        if (visibleElements.length > 0) {
            this.onLifecycle(() => visibleElements.map(([prop, propertyChain]) => {
                let base = this._instance.visibleElements ?? {};
                let defaultVisible = undefined;
                for (const key of propertyChain.slice(0, -1)) {
                    if (typeof base[key] === "object" && base[key] !== null)
                        base = base[key];
                    else {
                        defaultVisible = Boolean(base[key]);
                        break;
                    }
                }
                if (defaultVisible === undefined)
                    defaultVisible = Boolean(base[propertyChain.slice(-1)[0]] ?? true);
                prop.startsWith("hide") ? !defaultVisible : defaultVisible;
                const hideShowInName = prop.startsWith("hide") || prop.startsWith("show");
                const shouldFlip = hideShowInName ? prop.startsWith("hide") : defaultVisible;
                const genericComponent = this.component;
                if (typeof genericComponent[prop] === "boolean")
                    this._updateWidgetVisibleElement(propertyChain, genericComponent[prop], shouldFlip);
                else
                    genericComponent[prop] = false;
                return this.watch(prop, (rawVisible) => this._updateWidgetVisibleElement(propertyChain, rawVisible, shouldFlip));
            }));
        }
    }
    _updateWidgetVisibleElement(propertyChain, propValue, shouldFlip) {
        let base = this._instance.visibleElements ?? {};
        for (const key of propertyChain.slice(0, -1)) {
            if (typeof base[key] !== "object" || base[key] === null)
                base[key] = {};
            base = base[key];
        }
        const visible = Boolean(shouldFlip ? !propValue : propValue);
        base[propertyChain.at(-1)] = visible;
    }
    // This can't be in hostLoad as childElem is only accessible after first render
    hostLoaded() {
        const { el } = this.component;
        const childNode = el.shadowRoot?.firstChild ?? el.firstChild ?? undefined;
        /*
         * On hot reloading, new this.component instance is created (so properties
         * are reset) but this.component.el instance is preserved (so properties are
         * preserved). Since childElem is re-parented on 1st hostLoad(),
         * for it to be accessible on the 2nd hostLoad() (hot reload), we have to
         * store it's reference on the el, rather than component
         */
        el.childElem = childNode ?? el.childElem;
        this.component.childElem = el.childElem;
        this._instance.container = this.component.childElem ?? this.component.el;
        if (el.childElem === undefined && "production" !== "production")
            throw new Error("Unable to find reference to component's root child");
        // Define the "view" property if not already present for compatibility with JS API
        if (!("view" in this.component))
            Object.defineProperty(this.component, "view", {
                get: () => this._instance.view ?? this._instance.viewModel?.view,
                set: (view) => {
                    if (!("view" in this._instance) && typeof this._instance.viewModel === "object")
                        this._instance.viewModel.view = view;
                    else
                        this._instance.view = view;
                },
            });
        componentUtils.checkForView(this.component);
        this.component.arcgisReady.emit();
    }
    _watchMetaProperties() {
        this.watch("position", (position) => {
            if (this.component.childElem != null && typeof position === "string")
                this.component.view?.ui.move(this.component.childElem, position);
        });
        this.watch("referenceElement", (referenceElement) => void componentUtils.referenceElementHelper(this.component, referenceElement).catch(console.error));
    }
    _reEmitWidgetEvents() {
        const isEvented = "on" in this._instance && typeof this._instance.on === "function";
        if (!isEvented)
            return;
        const eventTarget = this._instance;
        Object.entries(this.component).forEach(([key, unknown]) => {
            const value = unknown;
            if (!key.startsWith("widget") ||
                key === "widget" ||
                typeof value !== "object" ||
                value === null ||
                !("emit" in value) ||
                typeof value.emit !== "function")
                return;
            const emit = value.emit;
            const trimmedEventName = key.slice("widget".length);
            const capitalizedEventName = index$1.kebabToPascal(trimmedEventName);
            const eventName = `${capitalizedEventName[0].toLowerCase()}${capitalizedEventName.slice(1)}`;
            this.onLifecycle(() => this.reactiveUtils.on(() => eventTarget, eventName, emit));
        });
    }
    hostDisconnected() {
        if (typeof this.component.childElem === "object")
            this.component.view?.ui.remove(this.component.childElem);
    }
    _makeVisibleElementsBinder() {
        return new Proxy({}, {
            has: (target, prop) => typeof prop === "string" || Reflect.has(target, prop),
            get: (target, prop) => {
                // Possibly called by the JS engine
                if (typeof prop === "symbol" || prop in Promise.prototype)
                    return Reflect.get(target, prop);
                const propertyChain = [prop];
                const proxy = this._makeRecursiveProxy(propertyChain);
                return this.component.manager.trackPropKey((resolvedKey) => {
                    if (resolvedKey === undefined)
                        throw new Error("Unable to bind visibleElements property. Check for incorrect this.widget.visibleElements usage");
                    this.component[resolvedKey] = false;
                    this._watchedVisibleElementsProperties[resolvedKey] = propertyChain;
                }, proxy, true);
            },
        });
    }
    _makeRecursiveProxy(propertyChain) {
        const chain = new Proxy({}, {
            get: (target, prop) => {
                const value = Reflect.get(target, prop);
                // Possibly called by the JS engine
                if (typeof prop === "symbol" || prop in Promise.prototype)
                    return value;
                propertyChain.push(prop);
                return chain;
            },
        });
        return chain;
    }
}
const proxy = chunkWQTCUXBS.proxyExports(WidgetController);

const compassCss = "";

const isOrientationEqual = (a, b) => a.z === b.z && a.y === b.y && a.x === b.x;
const useCompassWidget = makeWidgetController(index$2.newWidgetsCompass);
const ArcgisCompass = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.arcgisReady = index.createEvent(this, "arcgisReady", 7);
        this.arcgisPropertyChange = index.createEvent(this, "arcgisPropertyChange", 7);
        this.manager = chunkWQTCUXBS.useControllerManager(this);
        this.reactiveUtils = chunkWQTCUXBS.load(index$2.importCoreReactiveUtils);
        this.widget = useCompassWidget(this);
        this.viewModel = this.widget.viewModel;
        this.arcgisPropertyChange = chunkWQTCUXBS.usePropertyChange()("orientation");
        this.icon = this.widget.icon;
        this.label = this.widget.label;
        this.orientation = this.manager.getSet(
        // Assertion needed because JS API's type is "any"
        this.viewModel.orientation, {
            set: (newValue, oldValue) => (isOrientationEqual(newValue ?? {}, oldValue ?? {}) ? oldValue : newValue),
        });
        this.position = "bottom-left";
        this.referenceElement = undefined;
        this.state = this.viewModel.state;
    }
    //--------------------------------------------------------------------------
    //
    //  Methods
    //
    //--------------------------------------------------------------------------
    async reset() {
        this.widget.reset();
    }
    get el() { return index.getElement(this); }
};
ArcgisCompass.style = compassCss;

exports.arcgis_compass = ArcgisCompass;
