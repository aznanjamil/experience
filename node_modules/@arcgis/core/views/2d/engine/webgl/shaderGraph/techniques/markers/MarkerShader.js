/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.30/esri/copyright.txt for details.
*/
import{_ as t,a as e}from"../../../../../../../chunks/tslib.es6.js";import{location as i,option as o,uniform as s,ComputeVertexInput as l,input as r}from"../../GraphShaderModule.js";import{Vec3 as a,min as p,max as u,Float as n,Mat3 as d,Vec4 as m,ifElse as y,lessThan as h,equal as c,texture2D as x,clamp as V,abs as v,mix as w,distance as f,greaterThan as S,Vec2 as b,negate as g,step as z}from"../../graph/glsl.js";import{MarkerConstants as C}from"./markerConstants.js";import{FeatureVertexInput as M,FeatureFragmentInput as _,AFeatureShader as j}from"../shaders/AFeatureShader.js";import{c256ToRad as R,softEdgeRatio as U}from"../shaders/constants.js";import{distPointTriangle as N,xyToBarycentric as F,inTriangle as D,failHittest as I}from"../shaders/hittestUtils.js";import{MosaicInfo as O}from"../shaders/MosaicInfo.js";import{getBit as k,getBitBool as q,rgba2float as A}from"../shaders/utils.js";import{VisualVariableColor as P}from"../shaders/VisualVariableColor.js";import{VisualVariableOpacity as T}from"../shaders/VisualVariableOpacity.js";import{VisualVariableRotation as G}from"../shaders/VisualVariableRotation.js";import{VisualVariableSizeMinMaxValue as H}from"../shaders/VisualVariableSizeMinMaxValue.js";import{VisualVariableSizeScaleStops as L}from"../shaders/VisualVariableSizeScaleStops.js";import{VisualVariableSizeStops as B}from"../shaders/VisualVariableSizeStops.js";import{VisualVariableSizeUnitValue as E}from"../shaders/VisualVariableSizeUnitValue.js";import{getVisualVariableOpacity as J,getVisualVariableColor as K,getVisualVariableSize as Q,getVisualVariableRotation as W}from"../shaders/vvUtils.js";class X extends M{}t([i(3,m)],X.prototype,"color",void 0),t([i(4,m)],X.prototype,"outlineColor",void 0),t([i(5,b)],X.prototype,"offset",void 0),t([i(6,b)],X.prototype,"textureUV",void 0),t([i(7,m)],X.prototype,"sizing",void 0),t([i(8,n)],X.prototype,"placementAngle",void 0),t([i(9,n)],X.prototype,"sizeRatio",void 0),t([i(10,b)],X.prototype,"zoomRange",void 0);class Y extends l{}t([i(12,b)],Y.prototype,"offsetNextVertex1",void 0),t([i(13,b)],Y.prototype,"offsetNextVertex2",void 0),t([i(14,b)],Y.prototype,"textureUVNextVertex1",void 0),t([i(15,b)],Y.prototype,"textureUVNextVertex2",void 0);class Z extends _{}function $(t,e,i,o){return e.multiply(t.x).add(i.multiply(t.y)).add(o.multiply(t.z))}function tt(t){return t.multiply(t).divide(128)}class et extends j{constructor(){super(...arguments),this.computeAttributes={offset:["offsetNextVertex1","offsetNextVertex2"],textureUV:["textureUVNextVertex1","textureUVNextVertex2"]}}vertex(t,e){const i=tt(t.sizing.x),o=tt(t.sizing.y),s=tt(t.sizing.z),l=t.placementAngle,r=k(t.bitset,C.bitset.isSDF),y=k(t.bitset,C.bitset.isMapAligned),h=k(t.bitset,C.bitset.scaleSymbolsProportionally),c=q(t.bitset,C.bitset.colorLocked),x=J(this,t.id),V=K(this,t.id,t.color,c).multiply(x),v=this.view.displayViewScreenMat3.multiply(new a(t.pos.xy,1)),w=Q(this,t.id,s).divide(s),f=i.multiply(w),S=t.offset.xy.multiply(w);let b=o.multiply(h.multiply(w.subtract(1)).add(1));b=p(b,u(f.subtract(.99),new n(0)));const g=u(b,new n(1)),z=p(b,new n(1)),M=d.fromRotation(l.multiply(R)),_=W(this,t.id),j=this._getViewRotationMatrix(y).multiply(_).multiply(M).multiply(new a(S.xy,0)),U=this.clip(t.id,t.zoomRange),N=new m(v.xy.add(j.xy),U,1),F=t.textureUV.divide(this.mosaicInfo.size),D=t.outlineColor.multiply(z),I=k(t.bitset,C.bitset.overrideOutlineColor),O=t.sizeRatio.multiply(f).multiply(.5);return{glPosition:N,color:V,textureUV:F,outlineColor:D,outlineSize:g,distanceToPx:O,isSDF:r,overrideOutlineColor:I,...this.maybeRunHittest(t,e,{pos:t.pos,size:f,sizeCorrection:w,isMapAligned:y,outlineSize:g,distanceToPx:O,isSDF:r})}}fragment(t){const e=this._getColor(t.textureUV,t);return this.getFragmentOutput(e,t)}hittest(t,e,i){return y(h(i.size,this.hittestRequest.smallSymbolSizeThreshold),this._hittestSmallMarker(t,e,i),this._hittestMarker(t,e,i))}_getViewRotationMatrix(t){const e=this.view.displayViewMat3,i=this.view.displayMat3,o=new n(1).subtract(t);return e.multiply(t).add(i.multiply(o))}_getViewScreenMatrix(t){const e=this.view.viewMat3.multiply(this.view.tileMat3),i=this.view.tileMat3,o=new n(1).subtract(t);return e.multiply(t).add(i.multiply(o))}_getColor(t,e){return y(c(e.isSDF,new n(1)),this._getSDFColor(t,e),this._getSpriteColor(t,e))}_getSpriteColor(t,e){return x(this.mosaicInfo.texture,t).multiply(e.color)}_getSDFColor(t,e){const i=x(this.mosaicInfo.texture,t),o=new n(.5).subtract(A(i)).multiply(e.distanceToPx).multiply(U),s=V(new n(.5).subtract(o),new n(0),new n(1)),l=e.color.multiply(s);let r=e.outlineSize;this.highlight&&(r=u(r,e.overrideOutlineColor.multiply(4)));const a=r.multiply(.5),p=v(o).subtract(a),d=V(new n(.5).subtract(p),new n(0),new n(1)),m=w(e.outlineColor,e.color,e.overrideOutlineColor).multiply(d);return new n(1).subtract(m.a).multiply(l).add(m)}_hittestSmallMarker(t,e,i){const{position:o,distance:s,smallSymbolDistance:l}=this.hittestRequest,r=s.subtract(l),{viewMat3:p,tileMat3:u}=this.view,n=p.multiply(u).multiply(new a(i.pos,1)).xy,d=i.size.multiply(.5);return f(n,o).subtract(d).add(r)}_hittestMarker(t,e,i){const{pos:o,sizeCorrection:s,isMapAligned:l}=i,r=new a(t.offset.multiply(s),0),p=new a(e.offsetNextVertex1.multiply(s),0),u=new a(e.offsetNextVertex2.multiply(s),0),{viewMat3:n,tileMat3:d}=this.view,m=n.multiply(d).multiply(new a(o,1)),h=this._getViewScreenMatrix(l),c=m.add(h.multiply(r)).xy,x=m.add(h.multiply(p)).xy,V=m.add(h.multiply(u)).xy,v=this.hittestRequest.position,w=this.hittestRequest.distance,f=N(v,o,x,V);return y(S(f,w),f,this._hittestSamples(c,x,V,t,e,i))}_hittestSamples(t,e,i,o,s,l){const{outlineSize:r,isSDF:a,distanceToPx:p}=l,u=this.hittestRequest.position,d=this.hittestRequest.distance,y=F(u.add(new b(g(d),g(d))),t,e,i),h=F(u.add(new b(0,g(d))),t,e,i),c=F(u.add(new b(d,g(d))),t,e,i),x=F(u.add(new b(g(d),0)),t,e,i),V=F(u,t,e,i),v=F(u.add(new b(d,0)),t,e,i),w=F(u.add(new b(g(d),d)),t,e,i),f=F(u.add(new b(0,d)),t,e,i),S=F(u.add(new b(d,d)),t,e,i),C=o.textureUV.divide(this.mosaicInfo.size),M=s.textureUVNextVertex1.divide(this.mosaicInfo.size),_=s.textureUVNextVertex2.divide(this.mosaicInfo.size),j={color:new m(1),outlineColor:new m(1),overrideOutlineColor:new n(1),outlineSize:r,distanceToPx:p,isSDF:a};let R=new n(0);return R=R.add(D(y).multiply(this._getColor($(y,C,M,_),j).a)),R=R.add(D(h).multiply(this._getColor($(h,C,M,_),j).a)),R=R.add(D(c).multiply(this._getColor($(c,C,M,_),j).a)),R=R.add(D(x).multiply(this._getColor($(x,C,M,_),j).a)),R=R.add(D(V).multiply(this._getColor($(V,C,M,_),j).a)),R=R.add(D(v).multiply(this._getColor($(v,C,M,_),j).a)),R=R.add(D(w).multiply(this._getColor($(w,C,M,_),j).a)),R=R.add(D(f).multiply(this._getColor($(f,C,M,_),j).a)),R=R.add(D(S).multiply(this._getColor($(S,C,M,_),j).a)),z(R,new n(.05)).multiply(I(this.hittestRequest))}}t([o(P)],et.prototype,"visualVariableColor",void 0),t([o(T)],et.prototype,"visualVariableOpacity",void 0),t([o(G)],et.prototype,"visualVariableRotation",void 0),t([o(H)],et.prototype,"visualVariableSizeMinMaxValue",void 0),t([o(L)],et.prototype,"visualVariableSizeScaleStops",void 0),t([o(B)],et.prototype,"visualVariableSizeStops",void 0),t([o(E)],et.prototype,"visualVariableSizeUnitValue",void 0),t([s(O)],et.prototype,"mosaicInfo",void 0),t([e(0,r(X)),e(1,r(Y))],et.prototype,"vertex",null),t([e(0,r(Z))],et.prototype,"fragment",null);export{Z as MarkerFragmentInput,et as MarkerShader,X as MarkerVertexInput};
