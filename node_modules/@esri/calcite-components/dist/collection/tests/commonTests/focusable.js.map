{"version":3,"file":"focusable.js","sourceRoot":"","sources":["../../../../src/tests/commonTests/focusable.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,UAAU,CAAC;AAE9C,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AAGxC,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC,CAAC;AAqBlC;;;;;;;;;;;;;GAaG;AACH,MAAM,UAAU,SAAS,CAAC,kBAAsC,EAAE,OAA0B;IAC1F,EAAE,CAAC,cAAc,EAAE,KAAK,IAAI,EAAE;QAC5B,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,MAAM,aAAa,CAAC,kBAAkB,CAAC,CAAC;QAC9D,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACrC,MAAM,mBAAmB,GAAG,OAAO,EAAE,mBAAmB,IAAI,GAAG,CAAC;QAChE,MAAM,OAAO,CAAC,UAAU,CAAC,UAAU,EAAE,OAAO,EAAE,OAAO,CAAC,CAAC,CAAC,sCAAsC;QAE9F,IAAI,OAAO,EAAE,yBAAyB,EAAE,CAAC;YACvC,MAAM,CACJ,MAAM,IAAI,CAAC,KAAK,CACd,GAAG,EACH,CAAC,OAAoB,EAAE,QAAgB,EAAE,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,aAAa,EAAE,OAAO,CAAC,QAAQ,CAAC,EAC/F,OAAO,EAAE,yBAAyB,CACnC,CACF,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACf,CAAC;QAED,4CAA4C;QAC5C,MAAM,IAAI,CAAC,cAAc,EAAE,CAAC;QAE5B,MAAM,CAAC,MAAM,IAAI,CAAC,QAAQ,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,aAAa,EAAE,OAAO,CAAC,QAAQ,CAAC,EAAE,mBAAmB,CAAC,CAAC,CAAC,IAAI,CAC5G,IAAI,CACL,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import { toHaveNoViolations } from \"jest-axe\";\nimport {} from \"./../utils\";\nimport { getTagAndPage } from \"./utils\";\nimport { ComponentTestSetup } from \"./interfaces\";\n\nexpect.extend(toHaveNoViolations);\n\nexport interface FocusableOptions {\n  /**\n   * use this to pass an ID to setFocus()\n   *\n   * @deprecated components should no longer use a focusId parameter for setFocus()\n   */\n  focusId?: string;\n\n  /**\n   * selector used to assert the focused DOM element\n   */\n  focusTargetSelector?: string;\n\n  /**\n   * selector used to assert the focused shadow DOM element\n   */\n  shadowFocusTargetSelector?: string;\n}\n\n/**\n * Helper for asserting that a component is focusable\n *\n * Note that this helper should be used within a describe block.\n *\n * @example\n * describe(\"is focusable\", () => {\n *    focusable(`calcite-input-number`, { shadowFocusTargetSelector: \"input\" })\n * });\n *\n * @param {string} componentTagOrHTML - the component tag or HTML markup to test against\n * @param componentTestSetup\n * @param {FocusableOptions} [options] - additional options for asserting focus\n */\nexport function focusable(componentTestSetup: ComponentTestSetup, options?: FocusableOptions): void {\n  it(\"is focusable\", async () => {\n    const { page, tag } = await getTagAndPage(componentTestSetup);\n    const element = await page.find(tag);\n    const focusTargetSelector = options?.focusTargetSelector || tag;\n    await element.callMethod(\"setFocus\", options?.focusId); // assumes element is FocusableElement\n\n    if (options?.shadowFocusTargetSelector) {\n      expect(\n        await page.$eval(\n          tag,\n          (element: HTMLElement, selector: string) => element.shadowRoot.activeElement?.matches(selector),\n          options?.shadowFocusTargetSelector,\n        ),\n      ).toBe(true);\n    }\n\n    // wait for next frame before checking focus\n    await page.waitForChanges();\n\n    expect(await page.evaluate((selector) => document.activeElement?.matches(selector), focusTargetSelector)).toBe(\n      true,\n    );\n  });\n}\n"]}